<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ðŸŽµ VTT Editor Pro V3.0</title>
        <script>!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).WaveSurfer=e()}(this,(function(){"use strict";function t(t,e,i,n){return new(i||(i=Promise))((function(s,r){function o(t){try{l(n.next(t))}catch(t){r(t)}}function a(t){try{l(n.throw(t))}catch(t){r(t)}}function l(t){var e;t.done?s(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(o,a)}l((n=n.apply(t,e||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;class e{constructor(){this.listeners={}}on(t,e,i){if(this.listeners[t]||(this.listeners[t]=new Set),null==i?void 0:i.once){const i=(...n)=>{this.un(t,i),e(...n)};return this.listeners[t].add(i),()=>this.un(t,i)}return this.listeners[t].add(e),()=>this.un(t,e)}un(t,e){var i;null===(i=this.listeners[t])||void 0===i||i.delete(e)}once(t,e){return this.on(t,e,{once:!0})}unAll(){this.listeners={}}emit(t,...e){this.listeners[t]&&this.listeners[t].forEach((t=>t(...e)))}}const i={decode:function(e,i){return t(this,void 0,void 0,(function*(){const t=new AudioContext({sampleRate:i});try{return yield t.decodeAudioData(e)}finally{t.close()}}))},createBuffer:function(t,e){if(!t||0===t.length)throw new Error("channelData must be a non-empty array");if(e<=0)throw new Error("duration must be greater than 0");if("number"==typeof t[0]&&(t=[t]),!t[0]||0===t[0].length)throw new Error("channelData must contain non-empty channel arrays");!function(t){const e=t[0];if(e.some((t=>t>1||t<-1))){const i=e.length;let n=0;for(let t=0;t<i;t++){const i=Math.abs(e[t]);i>n&&(n=i)}for(const e of t)for(let t=0;t<i;t++)e[t]/=n}}(t);const i=t.map((t=>t instanceof Float32Array?t:Float32Array.from(t)));return{duration:e,length:i[0].length,sampleRate:i[0].length/e,numberOfChannels:i.length,getChannelData:t=>{const e=i[t];if(!e)throw new Error(`Channel ${t} not found`);return e},copyFromChannel:AudioBuffer.prototype.copyFromChannel,copyToChannel:AudioBuffer.prototype.copyToChannel}}};function n(t,e){const i=e.xmlns?document.createElementNS(e.xmlns,t):document.createElement(t);for(const[t,s]of Object.entries(e))if("children"===t&&s)for(const[t,e]of Object.entries(s))e instanceof Node?i.appendChild(e):"string"==typeof e?i.appendChild(document.createTextNode(e)):i.appendChild(n(t,e));else"style"===t?Object.assign(i.style,s):"textContent"===t?i.textContent=s:i.setAttribute(t,s.toString());return i}function s(t,e,i){const s=n(t,e||{});return null==i||i.appendChild(s),s}var r=Object.freeze({__proto__:null,createElement:s,default:s});const o={fetchBlob:function(e,i,n){return t(this,void 0,void 0,(function*(){const s=yield fetch(e,n);if(s.status>=400)throw new Error(`Failed to fetch ${e}: ${s.status} (${s.statusText})`);return function(e,i){t(this,void 0,void 0,(function*(){if(!e.body||!e.headers)return;const t=e.body.getReader(),n=Number(e.headers.get("Content-Length"))||0;let s=0;const r=t=>{s+=(null==t?void 0:t.length)||0;const e=Math.round(s/n*100);i(e)};try{for(;;){const e=yield t.read();if(e.done)break;r(e.value)}}catch(t){console.warn("Progress tracking error:",t)}}))}(s.clone(),i),s.blob()}))}};function a(t){let e=t;const i=new Set;return{get value(){return e},set(t){Object.is(e,t)||(e=t,i.forEach((t=>t(e))))},update(t){this.set(t(e))},subscribe:t=>(i.add(t),()=>i.delete(t))}}function l(t,e){const i=a(t());return e.forEach((e=>e.subscribe((()=>{const e=t();Object.is(i.value,e)||i.set(e)})))),{get value(){return i.value},subscribe:t=>i.subscribe(t)}}function h(t,e){let i;const n=()=>{i&&(i(),i=void 0),i=t()},s=e.map((t=>t.subscribe(n)));return n(),()=>{i&&(i(),i=void 0),s.forEach((t=>t()))}}class u extends e{get isPlayingSignal(){return this._isPlaying}get currentTimeSignal(){return this._currentTime}get durationSignal(){return this._duration}get volumeSignal(){return this._volume}get mutedSignal(){return this._muted}get playbackRateSignal(){return this._playbackRate}get seekingSignal(){return this._seeking}constructor(t){super(),this.isExternalMedia=!1,this.reactiveMediaEventCleanups=[],t.media?(this.media=t.media,this.isExternalMedia=!0):this.media=document.createElement("audio"),this._isPlaying=a(!1),this._currentTime=a(0),this._duration=a(0),this._volume=a(this.media.volume),this._muted=a(this.media.muted),this._playbackRate=a(this.media.playbackRate||1),this._seeking=a(!1),this.setupReactiveMediaEvents(),t.mediaControls&&(this.media.controls=!0),t.autoplay&&(this.media.autoplay=!0),null!=t.playbackRate&&this.onMediaEvent("canplay",(()=>{null!=t.playbackRate&&(this.media.playbackRate=t.playbackRate)}),{once:!0})}setupReactiveMediaEvents(){this.reactiveMediaEventCleanups.push(this.onMediaEvent("play",(()=>{this._isPlaying.set(!0)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("pause",(()=>{this._isPlaying.set(!1)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("ended",(()=>{this._isPlaying.set(!1)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("timeupdate",(()=>{this._currentTime.set(this.media.currentTime)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("durationchange",(()=>{this._duration.set(this.media.duration||0)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("loadedmetadata",(()=>{this._duration.set(this.media.duration||0)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("seeking",(()=>{this._seeking.set(!0)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("seeked",(()=>{this._seeking.set(!1)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("volumechange",(()=>{this._volume.set(this.media.volume),this._muted.set(this.media.muted)}))),this.reactiveMediaEventCleanups.push(this.onMediaEvent("ratechange",(()=>{this._playbackRate.set(this.media.playbackRate)})))}onMediaEvent(t,e,i){return this.media.addEventListener(t,e,i),()=>this.media.removeEventListener(t,e,i)}getSrc(){return this.media.currentSrc||this.media.src||""}revokeSrc(){const t=this.getSrc();t.startsWith("blob:")&&URL.revokeObjectURL(t)}canPlayType(t){return""!==this.media.canPlayType(t)}setSrc(t,e){const i=this.getSrc();if(t&&i===t)return;this.revokeSrc();const n=e instanceof Blob&&(this.canPlayType(e.type)||!t)?URL.createObjectURL(e):t;if(i&&this.media.removeAttribute("src"),n||t)try{this.media.src=n}catch(e){this.media.src=t}}destroy(){this.reactiveMediaEventCleanups.forEach((t=>t())),this.reactiveMediaEventCleanups=[],this.isExternalMedia||(this.media.pause(),this.revokeSrc(),this.media.removeAttribute("src"),this.media.load(),this.media.remove())}setMediaElement(t){this.reactiveMediaEventCleanups.forEach((t=>t())),this.reactiveMediaEventCleanups=[],this.media=t,this.setupReactiveMediaEvents()}play(){return t(this,void 0,void 0,(function*(){try{return yield this.media.play()}catch(t){if(t instanceof DOMException&&"AbortError"===t.name)return;throw t}}))}pause(){this.media.pause()}isPlaying(){return!this.media.paused&&!this.media.ended}setTime(t){this.media.currentTime=Math.max(0,Math.min(t,this.getDuration()))}getDuration(){return this.media.duration}getCurrentTime(){return this.media.currentTime}getVolume(){return this.media.volume}setVolume(t){this.media.volume=t}getMuted(){return this.media.muted}setMuted(t){this.media.muted=t}getPlaybackRate(){return this.media.playbackRate}isSeeking(){return this.media.seeking}setPlaybackRate(t,e){null!=e&&(this.media.preservesPitch=e),this.media.playbackRate=t}getMediaElement(){return this.media}setSinkId(t){return this.media.setSinkId(t)}}function c({maxTop:t,maxBottom:e,halfHeight:i,vScale:n,barMinHeight:s=0,barAlign:r}){let o=Math.round(t*i*n);let a=o+Math.round(e*i*n)||1;return a<s&&(a=s,r||(o=a/2)),{topHeight:o,totalHeight:a}}function d({barAlign:t,halfHeight:e,topHeight:i,totalHeight:n,canvasHeight:s}){return"top"===t?0:"bottom"===t?s-n:e-i}function p(t,e,i){const n=e-t.left,s=i-t.top;return[n/t.width,s/t.height]}function m(t){return Boolean(t.barWidth||t.barGap||t.barAlign)}function g(t,e){if(!m(e))return t;const i=e.barWidth||.5,n=i+(e.barGap||i/2);return 0===n?t:Math.floor(t/n)*n}function f({scrollLeft:t,totalWidth:e,numCanvases:i}){if(0===e)return[0];const n=t/e,s=Math.floor(n*i);return[s-1,s,s+1]}function v(t){const e=t._cleanup;"function"==typeof e&&e()}function b(t){const e=a({scrollLeft:t.scrollLeft,scrollWidth:t.scrollWidth,clientWidth:t.clientWidth}),i=l((()=>function(t){const{scrollLeft:e,scrollWidth:i,clientWidth:n}=t;if(0===i)return{startX:0,endX:1};const s=e/i,r=(e+n)/i;return{startX:Math.max(0,Math.min(1,s)),endX:Math.max(0,Math.min(1,r))}}(e.value)),[e]),n=l((()=>function(t){return{left:t.scrollLeft,right:t.scrollLeft+t.clientWidth}}(e.value)),[e]),s=()=>{e.set({scrollLeft:t.scrollLeft,scrollWidth:t.scrollWidth,clientWidth:t.clientWidth})};t.addEventListener("scroll",s,{passive:!0});return{scrollData:e,percentages:i,bounds:n,cleanup:()=>{t.removeEventListener("scroll",s),v(e)}}}class y extends e{constructor(t,e){super(),this.timeouts=[],this.isScrollable=!1,this.audioData=null,this.resizeObserver=null,this.lastContainerWidth=0,this.isDragging=!1,this.subscriptions=[],this.unsubscribeOnScroll=[],this.dragStream=null,this.scrollStream=null,this.subscriptions=[],this.options=t;const i=this.parentFromOptionsContainer(t.container);this.parent=i;const[n,s]=this.initHtml();i.appendChild(n),this.container=n,this.scrollContainer=s.querySelector(".scroll"),this.wrapper=s.querySelector(".wrapper"),this.canvasWrapper=s.querySelector(".canvases"),this.progressWrapper=s.querySelector(".progress"),this.cursor=s.querySelector(".cursor"),e&&s.appendChild(e),this.initEvents()}parentFromOptionsContainer(t){let e;if("string"==typeof t?e=document.querySelector(t):t instanceof HTMLElement&&(e=t),!e)throw new Error("Container not found");return e}initEvents(){this.wrapper.addEventListener("click",(t=>{const e=this.wrapper.getBoundingClientRect(),[i,n]=p(e,t.clientX,t.clientY);this.emit("click",i,n)})),this.wrapper.addEventListener("dblclick",(t=>{const e=this.wrapper.getBoundingClientRect(),[i,n]=p(e,t.clientX,t.clientY);this.emit("dblclick",i,n)})),!0!==this.options.dragToSeek&&"object"!=typeof this.options.dragToSeek||this.initDrag(),this.scrollStream=b(this.scrollContainer);const t=h((()=>{const{startX:t,endX:e}=this.scrollStream.percentages.value,{left:i,right:n}=this.scrollStream.bounds.value;this.emit("scroll",t,e,i,n)}),[this.scrollStream.percentages,this.scrollStream.bounds]);if(this.subscriptions.push(t),"function"==typeof ResizeObserver){const t=this.createDelay(100);this.resizeObserver=new ResizeObserver((()=>{t().then((()=>this.onContainerResize())).catch((()=>{}))})),this.resizeObserver.observe(this.scrollContainer)}}onContainerResize(){const t=this.parent.clientWidth;t===this.lastContainerWidth&&"auto"!==this.options.height||(this.lastContainerWidth=t,this.reRender(),this.emit("resize"))}initDrag(){if(this.dragStream)return;this.dragStream=function(t,e={}){const{threshold:i=3,mouseButton:n=0,touchDelay:s=100}=e,r=a(null),o=new Map,l=matchMedia("(pointer: coarse)").matches;let h=()=>{};const u=e=>{if(e.button!==n)return;if(o.set(e.pointerId,e),o.size>1)return;let a=e.clientX,u=e.clientY,c=!1;const d=Date.now(),p=t.getBoundingClientRect(),{left:m,top:g}=p,f=t=>{if(t.defaultPrevented||o.size>1)return;if(l&&Date.now()-d<s)return;const e=t.clientX,n=t.clientY,h=e-a,p=n-u;(c||Math.abs(h)>i||Math.abs(p)>i)&&(t.preventDefault(),t.stopPropagation(),c||(r.set({type:"start",x:a-m,y:u-g}),c=!0),r.set({type:"move",x:e-m,y:n-g,deltaX:h,deltaY:p}),a=e,u=n)},v=t=>{if(o.delete(t.pointerId),c){const e=t.clientX,i=t.clientY;r.set({type:"end",x:e-m,y:i-g})}h()},b=t=>{o.delete(t.pointerId),t.relatedTarget&&t.relatedTarget!==document.documentElement||v(t)},y=t=>{c&&(t.stopPropagation(),t.preventDefault())},C=t=>{t.defaultPrevented||o.size>1||c&&t.preventDefault()};document.addEventListener("pointermove",f),document.addEventListener("pointerup",v),document.addEventListener("pointerout",b),document.addEventListener("pointercancel",b),document.addEventListener("touchmove",C,{passive:!1}),document.addEventListener("click",y,{capture:!0}),h=()=>{document.removeEventListener("pointermove",f),document.removeEventListener("pointerup",v),document.removeEventListener("pointerout",b),document.removeEventListener("pointercancel",b),document.removeEventListener("touchmove",C),setTimeout((()=>{document.removeEventListener("click",y,{capture:!0})}),10)}};return t.addEventListener("pointerdown",u),{signal:r,cleanup:()=>{h(),t.removeEventListener("pointerdown",u),o.clear(),v(r)}}}(this.wrapper);const t=h((()=>{const t=this.dragStream.signal.value;if(!t)return;const e=this.wrapper.getBoundingClientRect().width,i=(n=t.x/e)<0?0:n>1?1:n;var n;"start"===t.type?(this.isDragging=!0,this.emit("dragstart",i)):"move"===t.type?this.emit("drag",i):"end"===t.type&&(this.isDragging=!1,this.emit("dragend",i))}),[this.dragStream.signal]);this.subscriptions.push(t)}initHtml(){const t=document.createElement("div"),e=t.attachShadow({mode:"open"}),i=this.options.cspNonce&&"string"==typeof this.options.cspNonce?this.options.cspNonce.replace(/"/g,""):"";return e.innerHTML=`\n      <style${i?` nonce="${i}"`:""}>\n        :host {\n          user-select: none;\n          min-width: 1px;\n        }\n        :host audio {\n          display: block;\n          width: 100%;\n        }\n        :host .scroll {\n          overflow-x: auto;\n          overflow-y: hidden;\n          width: 100%;\n          position: relative;\n        }\n        :host .noScrollbar {\n          scrollbar-color: transparent;\n          scrollbar-width: none;\n        }\n        :host .noScrollbar::-webkit-scrollbar {\n          display: none;\n          -webkit-appearance: none;\n        }\n        :host .wrapper {\n          position: relative;\n          overflow: visible;\n          z-index: 2;\n        }\n        :host .canvases {\n          min-height: ${this.getHeight(this.options.height,this.options.splitChannels)}px;\n          pointer-events: none;\n        }\n        :host .canvases > div {\n          position: relative;\n        }\n        :host canvas {\n          display: block;\n          position: absolute;\n          top: 0;\n          image-rendering: pixelated;\n        }\n        :host .progress {\n          pointer-events: none;\n          position: absolute;\n          z-index: 2;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          overflow: hidden;\n        }\n        :host .progress > div {\n          position: relative;\n        }\n        :host .cursor {\n          pointer-events: none;\n          position: absolute;\n          z-index: 5;\n          top: 0;\n          left: 0;\n          height: 100%;\n          border-radius: 2px;\n        }\n      </style>\n\n      <div class="scroll" part="scroll">\n        <div class="wrapper" part="wrapper">\n          <div class="canvases" part="canvases"></div>\n          <div class="progress" part="progress"></div>\n          <div class="cursor" part="cursor"></div>\n        </div>\n      </div>\n    `,[t,e]}setOptions(t){if(this.options.container!==t.container){const e=this.parentFromOptionsContainer(t.container);e.appendChild(this.container),this.parent=e}!0!==t.dragToSeek&&"object"!=typeof this.options.dragToSeek||this.initDrag(),this.options=t,this.reRender()}getWrapper(){return this.wrapper}getWidth(){return this.scrollContainer.clientWidth}getScroll(){return this.scrollContainer.scrollLeft}setScroll(t){this.scrollContainer.scrollLeft=t}setScrollPercentage(t){const{scrollWidth:e}=this.scrollContainer,i=e*t;this.setScroll(i)}destroy(){var t;this.subscriptions.forEach((t=>t())),this.container.remove(),this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=null),null===(t=this.unsubscribeOnScroll)||void 0===t||t.forEach((t=>t())),this.unsubscribeOnScroll=[],this.dragStream&&(this.dragStream.cleanup(),this.dragStream=null),this.scrollStream&&(this.scrollStream.cleanup(),this.scrollStream=null)}createDelay(t=10){let e,i;const n=()=>{e&&(clearTimeout(e),e=void 0),i&&(i(),i=void 0)};return this.timeouts.push(n),()=>new Promise(((s,r)=>{n(),i=r,e=setTimeout((()=>{e=void 0,i=void 0,s()}),t)}))}getHeight(t,e){var i;const n=(null===(i=this.audioData)||void 0===i?void 0:i.numberOfChannels)||1;return function({optionsHeight:t,optionsSplitChannels:e,parentHeight:i,numberOfChannels:n,defaultHeight:s=128}){if(null==t)return s;const r=Number(t);if(!isNaN(r))return r;if("auto"===t){const t=i||s;return(null==e?void 0:e.every((t=>!t.overlay)))?t/n:t}return s}({optionsHeight:t,optionsSplitChannels:e,parentHeight:this.parent.clientHeight,numberOfChannels:n,defaultHeight:128})}convertColorValues(t,e){return function(t,e,i){if(!Array.isArray(t))return t||"";if(0===t.length)return"#999";if(t.length<2)return t[0]||"";const n=document.createElement("canvas"),s=n.getContext("2d"),r=null!=i?i:n.height*e,o=s.createLinearGradient(0,0,0,r||e),a=1/(t.length-1);return t.forEach(((t,e)=>{o.addColorStop(e*a,t)})),o}(t,this.getPixelRatio(),null==e?void 0:e.canvas.height)}getPixelRatio(){return t=window.devicePixelRatio,Math.max(1,t||1);var t}renderBarWaveform(t,e,i,n){const{width:s,height:r}=i.canvas,{halfHeight:o,barWidth:a,barRadius:l,barIndexScale:h,barSpacing:u,barMinHeight:p}=function({width:t,height:e,length:i,options:n,pixelRatio:s}){const r=e/2,o=n.barWidth?n.barWidth*s:1,a=n.barGap?n.barGap*s:n.barWidth?o/2:0,l=o+a||1;return{halfHeight:r,barWidth:o,barGap:a,barRadius:n.barRadius||0,barMinHeight:n.barMinHeight?n.barMinHeight*s:0,barIndexScale:i>0?t/l/i:0,barSpacing:l}}({width:s,height:r,length:(t[0]||[]).length,options:e,pixelRatio:this.getPixelRatio()}),m=function({channelData:t,barIndexScale:e,barSpacing:i,barWidth:n,halfHeight:s,vScale:r,canvasHeight:o,barAlign:a,barMinHeight:l}){const h=t[0]||[],u=t[1]||h,p=h.length,m=[];let g=0,f=0,v=0;for(let t=0;t<=p;t++){const p=Math.round(t*e);if(p>g){const{topHeight:t,totalHeight:e}=c({maxTop:f,maxBottom:v,halfHeight:s,vScale:r,barMinHeight:l,barAlign:a}),h=d({barAlign:a,halfHeight:s,topHeight:t,totalHeight:e,canvasHeight:o});m.push({x:g*i,y:h,width:n,height:e}),g=p,f=0,v=0}const b=Math.abs(h[t]||0),y=Math.abs(u[t]||0);b>f&&(f=b),y>v&&(v=y)}return m}({channelData:t,barIndexScale:h,barSpacing:u,barWidth:a,halfHeight:o,vScale:n,canvasHeight:r,barAlign:e.barAlign,barMinHeight:p});i.beginPath();for(const t of m)l&&"roundRect"in i?i.roundRect(t.x,t.y,t.width,t.height,l):i.rect(t.x,t.y,t.width,t.height);i.fill(),i.closePath()}renderLineWaveform(t,e,i,n){const{width:s,height:r}=i.canvas,o=function({channelData:t,width:e,height:i,vScale:n}){const s=i/2,r=t[0]||[];return[r,t[1]||r].map(((t,i)=>{const r=t.length,o=r?e/r:0,a=s,l=0===i?-1:1,h=[{x:0,y:a}];let u=0,c=0;for(let e=0;e<=r;e++){const i=Math.round(e*o);if(i>u){const t=a+(Math.round(c*s*n)||1)*l;h.push({x:u,y:t}),u=i,c=0}const r=Math.abs(t[e]||0);r>c&&(c=r)}return h.push({x:u,y:a}),h}))}({channelData:t,width:s,height:r,vScale:n});i.beginPath();for(const t of o)if(t.length){i.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++){const n=t[e];i.lineTo(n.x,n.y)}}i.fill(),i.closePath()}renderWaveform(t,e,i){if(i.fillStyle=this.convertColorValues(e.waveColor,i),e.renderFunction)return void e.renderFunction(t,i);const n=function({channelData:t,barHeight:e,normalize:i,maxPeak:n}){var s;const r=e||1;if(!i)return r;const o=t[0];if(!o||0===o.length)return r;let a=null!=n?n:0;if(!n)for(let t=0;t<o.length;t++){const e=null!==(s=o[t])&&void 0!==s?s:0,i=Math.abs(e);i>a&&(a=i)}return a?r/a:r}({channelData:t,barHeight:e.barHeight,normalize:e.normalize,maxPeak:e.maxPeak});m(e)?this.renderBarWaveform(t,e,i,n):this.renderLineWaveform(t,e,i,n)}renderSingleCanvas(t,e,i,n,s,r,o){const a=this.getPixelRatio(),l=document.createElement("canvas");l.width=Math.round(i*a),l.height=Math.round(n*a),l.style.width=`${i}px`,l.style.height=`${n}px`,l.style.left=`${Math.round(s)}px`,r.appendChild(l);const h=l.getContext("2d");if(e.renderFunction?(h.fillStyle=this.convertColorValues(e.waveColor,h),e.renderFunction(t,h)):this.renderWaveform(t,e,h),l.width>0&&l.height>0){const t=l.cloneNode(),i=t.getContext("2d");i.drawImage(l,0,0),i.globalCompositeOperation="source-in",i.fillStyle=this.convertColorValues(e.progressColor,i),i.fillRect(0,0,l.width,l.height),o.appendChild(t)}}renderMultiCanvas(t,e,i,n,s,r){const o=this.getPixelRatio(),{clientWidth:a}=this.scrollContainer,l=i/o,h=function({clientWidth:t,totalWidth:e,options:i}){return g(Math.min(8e3,t,e),i)}({clientWidth:a,totalWidth:l,options:e});let u={};if(0===h)return;const c=i=>{if(i<0||i>=d)return;if(u[i])return;u[i]=!0;const o=i*h;let a=Math.min(l-o,h);if(a=g(a,e),a<=0)return;const c=function({channelData:t,offset:e,clampedWidth:i,totalWidth:n}){return t.map((t=>{const s=Math.floor(e/n*t.length),r=Math.floor((e+i)/n*t.length);return t.slice(s,r)}))}({channelData:t,offset:o,clampedWidth:a,totalWidth:l});this.renderSingleCanvas(c,e,a,n,o,s,r)},d=Math.ceil(l/h);if(!this.isScrollable){for(let t=0;t<d;t++)c(t);return}if(f({scrollLeft:this.scrollContainer.scrollLeft,totalWidth:l,numCanvases:d}).forEach((t=>c(t))),d>1){const t=this.on("scroll",(()=>{const{scrollLeft:t}=this.scrollContainer;Object.keys(u).length>10&&(s.innerHTML="",r.innerHTML="",u={}),f({scrollLeft:t,totalWidth:l,numCanvases:d}).forEach((t=>c(t)))}));this.unsubscribeOnScroll.push(t)}}renderChannel(t,e,i,n){var{overlay:s}=e,r=function(t,e){var i={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&e.indexOf(n)<0&&(i[n]=t[n]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(t);s<n.length;s++)e.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(t,n[s])&&(i[n[s]]=t[n[s]])}return i}(e,["overlay"]);const o=document.createElement("div"),a=this.getHeight(r.height,r.splitChannels);o.style.height=`${a}px`,s&&n>0&&(o.style.marginTop=`-${a}px`),this.canvasWrapper.style.minHeight=`${a}px`,this.canvasWrapper.appendChild(o);const l=o.cloneNode();this.progressWrapper.appendChild(l),this.renderMultiCanvas(t,r,i,a,o,l)}render(e){return t(this,void 0,void 0,(function*(){var t;this.timeouts.forEach((t=>t())),this.timeouts=[],this.canvasWrapper.innerHTML="",this.progressWrapper.innerHTML="",null!=this.options.width&&(this.scrollContainer.style.width="number"==typeof this.options.width?`${this.options.width}px`:this.options.width);const i=this.getPixelRatio(),n=this.scrollContainer.clientWidth,{scrollWidth:s,isScrollable:r,useParentWidth:o,width:a}=function({duration:t,minPxPerSec:e=0,parentWidth:i,fillParent:n,pixelRatio:s}){const r=Math.ceil(t*e),o=r>i,a=Boolean(n&&!o);return{scrollWidth:r,isScrollable:o,useParentWidth:a,width:(a?i:r)*s}}({duration:e.duration,minPxPerSec:this.options.minPxPerSec||0,parentWidth:n,fillParent:this.options.fillParent,pixelRatio:i});if(this.isScrollable=r,this.wrapper.style.width=o?"100%":`${s}px`,this.scrollContainer.style.overflowX=this.isScrollable?"auto":"hidden",this.scrollContainer.classList.toggle("noScrollbar",!!this.options.hideScrollbar),this.cursor.style.backgroundColor=`${this.options.cursorColor||this.options.progressColor}`,this.cursor.style.width=`${this.options.cursorWidth}px`,this.audioData=e,this.emit("render"),this.options.splitChannels)for(let i=0;i<e.numberOfChannels;i++){const n=Object.assign(Object.assign({},this.options),null===(t=this.options.splitChannels)||void 0===t?void 0:t[i]);this.renderChannel([e.getChannelData(i)],n,a,i)}else{const t=[e.getChannelData(0)];e.numberOfChannels>1&&t.push(e.getChannelData(1)),this.renderChannel(t,this.options,a,0)}Promise.resolve().then((()=>this.emit("rendered")))}))}reRender(){if(this.unsubscribeOnScroll.forEach((t=>t())),this.unsubscribeOnScroll=[],!this.audioData)return;const{scrollWidth:t}=this.scrollContainer,{right:e}=this.progressWrapper.getBoundingClientRect();if(this.render(this.audioData),this.isScrollable&&t!==this.scrollContainer.scrollWidth){const{right:t}=this.progressWrapper.getBoundingClientRect(),i=function(t){const e=2*t;return(e<0?Math.floor(e):Math.ceil(e))/2}(t-e);this.scrollContainer.scrollLeft+=i}}zoom(t){this.options.minPxPerSec=t,this.reRender()}scrollIntoView(t,e=!1){const{scrollLeft:i,scrollWidth:n,clientWidth:s}=this.scrollContainer,r=t*n,o=i,a=i+s,l=s/2;if(this.isDragging){const t=30;r+t>a?this.scrollContainer.scrollLeft+=t:r-t<o&&(this.scrollContainer.scrollLeft-=t)}else{(r<o||r>a)&&(this.scrollContainer.scrollLeft=r-(this.options.autoCenter?l:0));const t=r-i-l;e&&this.options.autoCenter&&t>0&&(this.scrollContainer.scrollLeft+=t)}}renderProgress(t,e){if(isNaN(t))return;const i=100*t;this.canvasWrapper.style.clipPath=`polygon(${i}% 0%, 100% 0%, 100% 100%, ${i}% 100%)`,this.progressWrapper.style.width=`${i}%`,this.cursor.style.left=`${i}%`,this.cursor.style.transform=this.options.cursorWidth?`translateX(-${t*this.options.cursorWidth}px)`:"",this.isScrollable&&this.options.autoScroll&&this.audioData&&this.audioData.duration>0&&this.scrollIntoView(t,e)}exportImage(e,i,n){return t(this,void 0,void 0,(function*(){const t=this.canvasWrapper.querySelectorAll("canvas");if(!t.length)throw new Error("No waveform data");if("dataURL"===n){const n=Array.from(t).map((t=>t.toDataURL(e,i)));return Promise.resolve(n)}return Promise.all(Array.from(t).map((t=>new Promise(((n,s)=>{t.toBlob((t=>{t?n(t):s(new Error("Could not export image"))}),e,i)})))))}))}}class C extends e{constructor(){super(...arguments),this.animationFrameId=null,this.isRunning=!1}start(){if(this.isRunning)return;this.isRunning=!0;const t=()=>{this.isRunning&&(this.emit("tick"),this.animationFrameId=requestAnimationFrame(t))};t()}stop(){this.isRunning=!1,null!==this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null)}destroy(){this.stop()}}class S extends e{constructor(t=new AudioContext){super(),this.bufferNode=null,this.playStartTime=0,this.playedDuration=0,this._muted=!1,this._playbackRate=1,this._duration=void 0,this.buffer=null,this.currentSrc="",this.paused=!0,this.crossOrigin=null,this.seeking=!1,this.autoplay=!1,this.addEventListener=this.on,this.removeEventListener=this.un,this.audioContext=t,this.gainNode=this.audioContext.createGain(),this.gainNode.connect(this.audioContext.destination)}load(){return t(this,void 0,void 0,(function*(){}))}get src(){return this.currentSrc}set src(t){if(this.currentSrc=t,this._duration=void 0,!t)return this.buffer=null,void this.emit("emptied");fetch(t).then((e=>{if(e.status>=400)throw new Error(`Failed to fetch ${t}: ${e.status} (${e.statusText})`);return e.arrayBuffer()})).then((e=>this.currentSrc!==t?null:this.audioContext.decodeAudioData(e))).then((e=>{this.currentSrc===t&&(this.buffer=e,this.emit("loadedmetadata"),this.emit("canplay"),this.autoplay&&this.play())})).catch((t=>{console.error("WebAudioPlayer load error:",t)}))}_play(){if(!this.paused)return;this.paused=!1,this.bufferNode&&(this.bufferNode.onended=null,this.bufferNode.disconnect()),this.bufferNode=this.audioContext.createBufferSource(),this.buffer&&(this.bufferNode.buffer=this.buffer),this.bufferNode.playbackRate.value=this._playbackRate,this.bufferNode.connect(this.gainNode);let t=this.playedDuration*this._playbackRate;(t>=this.duration||t<0)&&(t=0,this.playedDuration=0),this.bufferNode.start(this.audioContext.currentTime,t),this.playStartTime=this.audioContext.currentTime,this.bufferNode.onended=()=>{this.currentTime>=this.duration&&(this.pause(),this.emit("ended"))}}_pause(){var t;this.paused=!0,null===(t=this.bufferNode)||void 0===t||t.stop(),this.playedDuration+=this.audioContext.currentTime-this.playStartTime}play(){return t(this,void 0,void 0,(function*(){this.paused&&(this._play(),this.emit("play"))}))}pause(){this.paused||(this._pause(),this.emit("pause"))}stopAt(t){const e=t-this.currentTime,i=this.bufferNode;null==i||i.stop(this.audioContext.currentTime+e),null==i||i.addEventListener("ended",(()=>{i===this.bufferNode&&(this.bufferNode=null,this.pause())}),{once:!0})}setSinkId(e){return t(this,void 0,void 0,(function*(){return this.audioContext.setSinkId(e)}))}get playbackRate(){return this._playbackRate}set playbackRate(t){this._playbackRate=t,this.bufferNode&&(this.bufferNode.playbackRate.value=t)}get currentTime(){return(this.paused?this.playedDuration:this.playedDuration+(this.audioContext.currentTime-this.playStartTime))*this._playbackRate}set currentTime(t){const e=!this.paused;e&&this._pause(),this.playedDuration=t/this._playbackRate,e&&this._play(),this.emit("seeking"),this.emit("timeupdate")}get duration(){var t,e;return null!==(t=this._duration)&&void 0!==t?t:(null===(e=this.buffer)||void 0===e?void 0:e.duration)||0}set duration(t){this._duration=t}get volume(){return this.gainNode.gain.value}set volume(t){this.gainNode.gain.value=t,this.emit("volumechange")}get muted(){return this._muted}set muted(t){this._muted!==t&&(this._muted=t,this._muted?this.gainNode.disconnect():this.gainNode.connect(this.audioContext.destination))}canPlayType(t){return/^(audio|video)\//.test(t)}getGainNode(){return this.gainNode}getChannelData(){const t=[];if(!this.buffer)return t;const e=this.buffer.numberOfChannels;for(let i=0;i<e;i++)t.push(this.buffer.getChannelData(i));return t}removeAttribute(t){switch(t){case"src":this.src="";break;case"playbackRate":this.playbackRate=0;break;case"currentTime":this.currentTime=0;break;case"duration":this.duration=0;break;case"volume":this.volume=0;break;case"muted":this.muted=!1}}}const E={waveColor:"#999",progressColor:"#555",cursorWidth:1,minPxPerSec:0,fillParent:!0,interact:!0,dragToSeek:!1,autoScroll:!0,autoCenter:!0,sampleRate:8e3};class w extends u{static create(t){return new w(t)}getState(){return this.wavesurferState}getRenderer(){return this.renderer}constructor(t){const e=t.media||("WebAudio"===t.backend?new S:void 0);super({media:e,mediaControls:t.mediaControls,autoplay:t.autoplay,playbackRate:t.audioRate}),this.plugins=[],this.decodedData=null,this.stopAtPosition=null,this.subscriptions=[],this.mediaSubscriptions=[],this.abortController=null,this.reactiveCleanups=[],this.options=Object.assign({},E,t);const{state:i,actions:n}=function(t){var e,i,n,s,r,o;const h=null!==(e=null==t?void 0:t.currentTime)&&void 0!==e?e:a(0),u=null!==(i=null==t?void 0:t.duration)&&void 0!==i?i:a(0),c=null!==(n=null==t?void 0:t.isPlaying)&&void 0!==n?n:a(!1),d=null!==(s=null==t?void 0:t.isSeeking)&&void 0!==s?s:a(!1),p=null!==(r=null==t?void 0:t.volume)&&void 0!==r?r:a(1),m=null!==(o=null==t?void 0:t.playbackRate)&&void 0!==o?o:a(1),g=a(null),f=a(null),v=a(""),b=a(0),y=a(0),C=l((()=>!c.value),[c]),S=l((()=>null!==g.value),[g]),E=l((()=>S.value&&u.value>0),[S,u]),w=l((()=>h.value),[h]),P=l((()=>u.value>0?h.value/u.value:0),[h,u]);return{state:{currentTime:h,duration:u,isPlaying:c,isPaused:C,isSeeking:d,volume:p,playbackRate:m,audioBuffer:g,peaks:f,url:v,zoom:b,scrollPosition:y,canPlay:S,isReady:E,progress:w,progressPercent:P},actions:{setCurrentTime:t=>{const e=Math.max(0,Math.min(u.value||1/0,t));h.set(e)},setDuration:t=>{u.set(Math.max(0,t))},setPlaying:t=>{c.set(t)},setSeeking:t=>{d.set(t)},setVolume:t=>{const e=Math.max(0,Math.min(1,t));p.set(e)},setPlaybackRate:t=>{const e=Math.max(.1,Math.min(16,t));m.set(e)},setAudioBuffer:t=>{g.set(t),t&&u.set(t.duration)},setPeaks:t=>{f.set(t)},setUrl:t=>{v.set(t)},setZoom:t=>{b.set(Math.max(0,t))},setScrollPosition:t=>{y.set(Math.max(0,t))}}}}({isPlaying:this.isPlayingSignal,currentTime:this.currentTimeSignal,duration:this.durationSignal,volume:this.volumeSignal,playbackRate:this.playbackRateSignal,isSeeking:this.seekingSignal});this.wavesurferState=i,this.wavesurferActions=n,this.timer=new C;const s=e?void 0:this.getMediaElement();this.renderer=new y(this.options,s),this.initPlayerEvents(),this.initRendererEvents(),this.initTimerEvents(),this.initReactiveState(),this.initPlugins();const r=this.options.url||this.getSrc()||"";Promise.resolve().then((()=>{this.emit("init");const{peaks:t,duration:e}=this.options;(r||t&&e)&&this.load(r,t,e).catch((t=>{this.emit("error",t instanceof Error?t:new Error(String(t)))}))}))}updateProgress(t=this.getCurrentTime()){return this.renderer.renderProgress(t/this.getDuration(),this.isPlaying()),t}initTimerEvents(){this.subscriptions.push(this.timer.on("tick",(()=>{if(!this.isSeeking()){const t=this.updateProgress();this.emit("timeupdate",t),this.emit("audioprocess",t),null!=this.stopAtPosition&&this.isPlaying()&&t>=this.stopAtPosition&&this.pause()}})))}initReactiveState(){this.reactiveCleanups.push(function(t,e){const i=[];i.push(h((()=>{const i=t.isPlaying.value;e.emit(i?"play":"pause")}),[t.isPlaying])),i.push(h((()=>{const i=t.currentTime.value;e.emit("timeupdate",i),t.isPlaying.value&&e.emit("audioprocess",i)}),[t.currentTime,t.isPlaying])),i.push(h((()=>{t.isSeeking.value&&e.emit("seeking",t.currentTime.value)}),[t.isSeeking,t.currentTime]));let n=!1;i.push(h((()=>{t.isReady.value&&!n&&(n=!0,e.emit("ready",t.duration.value))}),[t.isReady,t.duration]));let s=!1;return i.push(h((()=>{const i=t.isPlaying.value,n=t.currentTime.value,r=t.duration.value,o=r>0&&n>=r;s&&!i&&o&&e.emit("finish"),s=i&&o}),[t.isPlaying,t.currentTime,t.duration])),i.push(h((()=>{const i=t.zoom.value;i>0&&e.emit("zoom",i)}),[t.zoom])),()=>{i.forEach((t=>t()))}}(this.wavesurferState,{emit:this.emit.bind(this)}))}initPlayerEvents(){this.isPlaying()&&(this.emit("play"),this.timer.start()),this.mediaSubscriptions.push(this.onMediaEvent("timeupdate",(()=>{const t=this.updateProgress();this.emit("timeupdate",t)})),this.onMediaEvent("play",(()=>{this.emit("play"),this.timer.start()})),this.onMediaEvent("pause",(()=>{this.emit("pause"),this.timer.stop(),this.stopAtPosition=null})),this.onMediaEvent("emptied",(()=>{this.timer.stop(),this.stopAtPosition=null})),this.onMediaEvent("ended",(()=>{this.emit("timeupdate",this.getDuration()),this.emit("finish"),this.stopAtPosition=null})),this.onMediaEvent("seeking",(()=>{this.emit("seeking",this.getCurrentTime())})),this.onMediaEvent("error",(()=>{var t;this.emit("error",null!==(t=this.getMediaElement().error)&&void 0!==t?t:new Error("Media error")),this.stopAtPosition=null})))}initRendererEvents(){this.subscriptions.push(this.renderer.on("click",((t,e)=>{this.options.interact&&(this.seekTo(t),this.emit("interaction",t*this.getDuration()),this.emit("click",t,e))})),this.renderer.on("dblclick",((t,e)=>{this.emit("dblclick",t,e)})),this.renderer.on("scroll",((t,e,i,n)=>{const s=this.getDuration();this.emit("scroll",t*s,e*s,i,n)})),this.renderer.on("render",(()=>{this.emit("redraw")})),this.renderer.on("rendered",(()=>{this.emit("redrawcomplete")})),this.renderer.on("dragstart",(t=>{this.emit("dragstart",t)})),this.renderer.on("dragend",(t=>{this.emit("dragend",t)})),this.renderer.on("resize",(()=>{this.emit("resize")})));{let t;const e=this.renderer.on("drag",(e=>{var i;if(!this.options.interact)return;this.renderer.renderProgress(e),clearTimeout(t);let n=0;const s=this.options.dragToSeek;this.isPlaying()?n=0:!0===s?n=200:s&&"object"==typeof s&&(n=null!==(i=s.debounceTime)&&void 0!==i?i:200),t=setTimeout((()=>{this.seekTo(e)}),n),this.emit("interaction",e*this.getDuration()),this.emit("drag",e)}));this.subscriptions.push((()=>{clearTimeout(t),e()}))}}initPlugins(){var t;(null===(t=this.options.plugins)||void 0===t?void 0:t.length)&&this.options.plugins.forEach((t=>{this.registerPlugin(t)}))}unsubscribePlayerEvents(){this.mediaSubscriptions.forEach((t=>t())),this.mediaSubscriptions=[]}setOptions(t){this.options=Object.assign({},this.options,t),t.duration&&!t.peaks&&(this.decodedData=i.createBuffer(this.exportPeaks(),t.duration)),t.peaks&&t.duration&&(this.decodedData=i.createBuffer(t.peaks,t.duration)),this.renderer.setOptions(this.options),t.audioRate&&this.setPlaybackRate(t.audioRate),null!=t.mediaControls&&(this.getMediaElement().controls=t.mediaControls)}registerPlugin(t){if(this.plugins.includes(t))return t;t._init(this),this.plugins.push(t);const e=t.once("destroy",(()=>{this.plugins=this.plugins.filter((e=>e!==t)),this.subscriptions=this.subscriptions.filter((t=>t!==e))}));return this.subscriptions.push(e),t}unregisterPlugin(t){this.plugins=this.plugins.filter((e=>e!==t)),t.destroy()}getWrapper(){return this.renderer.getWrapper()}getWidth(){return this.renderer.getWidth()}getScroll(){return this.renderer.getScroll()}setScroll(t){return this.renderer.setScroll(t)}setScrollTime(t){const e=t/this.getDuration();this.renderer.setScrollPercentage(e)}getActivePlugins(){return this.plugins}loadAudio(e,n,s,r){return t(this,void 0,void 0,(function*(){var t;if(this.emit("load",e),!this.options.media&&this.isPlaying()&&this.pause(),this.decodedData=null,this.stopAtPosition=null,null===(t=this.abortController)||void 0===t||t.abort(),this.abortController=null,!n&&!s){const t=this.options.fetchParams||{};window.AbortController&&!t.signal&&(this.abortController=new AbortController,t.signal=this.abortController.signal);const i=t=>this.emit("loading",t);n=yield o.fetchBlob(e,i,t);const s=this.options.blobMimeType;s&&(n=new Blob([n],{type:s}))}this.setSrc(e,n);const a=yield new Promise((t=>{const e=r||this.getDuration();e?t(e):this.mediaSubscriptions.push(this.onMediaEvent("loadedmetadata",(()=>t(this.getDuration())),{once:!0}))}));if(!e&&!n){const t=this.getMediaElement();t instanceof S&&(t.duration=a)}if(s)this.decodedData=i.createBuffer(s,a||0);else if(n){const t=yield n.arrayBuffer();this.decodedData=yield i.decode(t,this.options.sampleRate)}this.decodedData&&(this.emit("decode",this.getDuration()),this.renderer.render(this.decodedData)),this.emit("ready",this.getDuration())}))}load(e,i,n){return t(this,void 0,void 0,(function*(){try{return yield this.loadAudio(e,void 0,i,n)}catch(t){throw this.emit("error",t),t}}))}loadBlob(e,i,n){return t(this,void 0,void 0,(function*(){try{return yield this.loadAudio("",e,i,n)}catch(t){throw this.emit("error",t),t}}))}zoom(t){if(!this.decodedData)throw new Error("No audio loaded");this.renderer.zoom(t),this.emit("zoom",t)}getDecodedData(){return this.decodedData}exportPeaks({channels:t=2,maxLength:e=8e3,precision:i=1e4}={}){if(!this.decodedData)throw new Error("The audio has not been decoded yet");const n=Math.min(t,this.decodedData.numberOfChannels),s=[];for(let t=0;t<n;t++){const n=this.decodedData.getChannelData(t),r=[],o=n.length/e;for(let t=0;t<e;t++){const e=n.slice(Math.floor(t*o),Math.ceil((t+1)*o));let s=0;for(let t=0;t<e.length;t++){const i=e[t];Math.abs(i)>Math.abs(s)&&(s=i)}r.push(Math.round(s*i)/i)}s.push(r)}return s}getDuration(){let t=super.getDuration()||0;return 0!==t&&t!==1/0||!this.decodedData||(t=this.decodedData.duration),t}toggleInteraction(t){this.options.interact=t}setTime(t){this.stopAtPosition=null,super.setTime(t),this.updateProgress(t),this.emit("timeupdate",t)}seekTo(t){const e=this.getDuration()*t;this.setTime(e)}play(e,i){const n=Object.create(null,{play:{get:()=>super.play}});return t(this,void 0,void 0,(function*(){null!=e&&this.setTime(e);const t=yield n.play.call(this);return null!=i&&(this.media instanceof S?this.media.stopAt(i):this.stopAtPosition=i),t}))}playPause(){return t(this,void 0,void 0,(function*(){return this.isPlaying()?this.pause():this.play()}))}stop(){this.pause(),this.setTime(0)}skip(t){this.setTime(this.getCurrentTime()+t)}empty(){this.load("",[[0]],.001)}setMediaElement(t){this.unsubscribePlayerEvents(),super.setMediaElement(t),this.initPlayerEvents()}exportImage(){return t(this,arguments,void 0,(function*(t="image/png",e=1,i="dataURL"){return this.renderer.exportImage(t,e,i)}))}destroy(){var t;this.emit("destroy"),null===(t=this.abortController)||void 0===t||t.abort(),this.plugins.forEach((t=>t.destroy())),this.subscriptions.forEach((t=>t())),this.unsubscribePlayerEvents(),this.reactiveCleanups.forEach((t=>t())),this.reactiveCleanups=[],this.timer.destroy(),this.renderer.destroy(),super.destroy()}}return w.BasePlugin=class extends e{constructor(t){super(),this.subscriptions=[],this.isDestroyed=!1,this.options=t}onInit(){}_init(t){this.isDestroyed&&(this.subscriptions=[],this.isDestroyed=!1),this.wavesurfer=t,this.onInit()}destroy(){this.emit("destroy"),this.subscriptions.forEach((t=>t())),this.subscriptions=[],this.isDestroyed=!0,this.wavesurfer=void 0}},w.dom=r,w}));</script>
        <script>!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):((t="undefined"!=typeof globalThis?globalThis:t||self).WaveSurfer=t.WaveSurfer||{},t.WaveSurfer.Regions=e())}(this,(function(){"use strict";class t{constructor(){this.listeners={}}on(t,e,i){if(this.listeners[t]||(this.listeners[t]=new Set),null==i?void 0:i.once){const i=(...n)=>{this.un(t,i),e(...n)};return this.listeners[t].add(i),()=>this.un(t,i)}return this.listeners[t].add(e),()=>this.un(t,e)}un(t,e){var i;null===(i=this.listeners[t])||void 0===i||i.delete(e)}once(t,e){return this.on(t,e,{once:!0})}unAll(){this.listeners={}}emit(t,...e){this.listeners[t]&&this.listeners[t].forEach((t=>t(...e)))}}class e extends t{constructor(t){super(),this.subscriptions=[],this.isDestroyed=!1,this.options=t}onInit(){}_init(t){this.isDestroyed&&(this.subscriptions=[],this.isDestroyed=!1),this.wavesurfer=t,this.onInit()}destroy(){this.emit("destroy"),this.subscriptions.forEach((t=>t())),this.subscriptions=[],this.isDestroyed=!0,this.wavesurfer=void 0}}function i(t,e){const n=e.xmlns?document.createElementNS(e.xmlns,t):document.createElement(t);for(const[t,s]of Object.entries(e))if("children"===t&&s)for(const[t,e]of Object.entries(s))e instanceof Node?n.appendChild(e):"string"==typeof e?n.appendChild(document.createTextNode(e)):n.appendChild(i(t,e));else"style"===t?Object.assign(n.style,s):"textContent"===t?n.textContent=s:n.setAttribute(t,s.toString());return n}function n(t,e,n){const s=i(t,e||{});return null==n||n.appendChild(s),s}function s(t){let e=t;const i=new Set;return{get value(){return e},set(t){Object.is(e,t)||(e=t,i.forEach((t=>t(e))))},update(t){this.set(t(e))},subscribe:t=>(i.add(t),()=>i.delete(t))}}function r(t,e){let i;const n=()=>{i&&(i(),i=void 0),i=t()},s=e.map((t=>t.subscribe(n)));return n(),()=>{i&&(i(),i=void 0),s.forEach((t=>t()))}}function o(t,e){const i=s(null),n=t=>{i.set(t)};return t.addEventListener(e,n),i._cleanup=()=>{t.removeEventListener(e,n)},i}function l(t){const e=t._cleanup;"function"==typeof e&&e()}function h(t,e={}){const{threshold:i=3,mouseButton:n=0,touchDelay:r=100}=e,o=s(null),h=new Map,a=matchMedia("(pointer: coarse)").matches;let d=()=>{};const c=e=>{if(e.button!==n)return;if(h.set(e.pointerId,e),h.size>1)return;let s=e.clientX,l=e.clientY,c=!1;const u=Date.now(),v=t.getBoundingClientRect(),{left:p,top:g}=v,m=t=>{if(t.defaultPrevented||h.size>1)return;if(a&&Date.now()-u<r)return;const e=t.clientX,n=t.clientY,d=e-s,v=n-l;(c||Math.abs(d)>i||Math.abs(v)>i)&&(t.preventDefault(),t.stopPropagation(),c||(o.set({type:"start",x:s-p,y:l-g}),c=!0),o.set({type:"move",x:e-p,y:n-g,deltaX:d,deltaY:v}),s=e,l=n)},f=t=>{if(h.delete(t.pointerId),c){const e=t.clientX,i=t.clientY;o.set({type:"end",x:e-p,y:i-g})}d()},b=t=>{h.delete(t.pointerId),t.relatedTarget&&t.relatedTarget!==document.documentElement||f(t)},E=t=>{c&&(t.stopPropagation(),t.preventDefault())},C=t=>{t.defaultPrevented||h.size>1||c&&t.preventDefault()};document.addEventListener("pointermove",m),document.addEventListener("pointerup",f),document.addEventListener("pointerout",b),document.addEventListener("pointercancel",b),document.addEventListener("touchmove",C,{passive:!1}),document.addEventListener("click",E,{capture:!0}),d=()=>{document.removeEventListener("pointermove",m),document.removeEventListener("pointerup",f),document.removeEventListener("pointerout",b),document.removeEventListener("pointercancel",b),document.removeEventListener("touchmove",C),setTimeout((()=>{document.removeEventListener("click",E,{capture:!0})}),10)}};t.addEventListener("pointerdown",c);return{signal:o,cleanup:()=>{d(),t.removeEventListener("pointerdown",c),h.clear(),l(o)}}}class a extends t{constructor(t,e,i=0){var n,s,r,o,l,h,a,d,c,u;super(),this.totalDuration=e,this.numberOfChannels=i,this.element=null,this.minLength=0,this.maxLength=1/0,this.contentEditable=!1,this.subscriptions=[],this.updatingSide=void 0,this.isRemoved=!1,this.subscriptions=[],this.id=t.id||`region-${Math.random().toString(32).slice(2)}`,this.start=this.clampPosition(t.start),this.end=this.clampPosition(null!==(n=t.end)&&void 0!==n?n:t.start),this.drag=null===(s=t.drag)||void 0===s||s,this.resize=null===(r=t.resize)||void 0===r||r,this.resizeStart=null===(o=t.resizeStart)||void 0===o||o,this.resizeEnd=null===(l=t.resizeEnd)||void 0===l||l,this.color=null!==(h=t.color)&&void 0!==h?h:"rgba(0, 0, 0, 0.1)",this.minLength=null!==(a=t.minLength)&&void 0!==a?a:this.minLength,this.maxLength=null!==(d=t.maxLength)&&void 0!==d?d:this.maxLength,this.channelIdx=null!==(c=t.channelIdx)&&void 0!==c?c:-1,this.contentEditable=null!==(u=t.contentEditable)&&void 0!==u?u:this.contentEditable,this.element=this.initElement(),this.setContent(t.content),this.setPart(),this.renderPosition(),this.initMouseEvents()}clampPosition(t){return Math.max(0,Math.min(this.totalDuration,t))}setPart(){var t;const e=this.start===this.end;null===(t=this.element)||void 0===t||t.setAttribute("part",`${e?"marker":"region"} ${this.id}`)}addResizeHandles(t){const e={position:"absolute",zIndex:"2",width:"6px",height:"100%",top:"0",cursor:"ew-resize",wordBreak:"keep-all"},i=n("div",{part:"region-handle region-handle-left",style:Object.assign(Object.assign({},e),{left:"0",borderLeft:"2px solid rgba(0, 0, 0, 0.5)",borderRadius:"2px 0 0 2px"})},t),s=n("div",{part:"region-handle region-handle-right",style:Object.assign(Object.assign({},e),{right:"0",borderRight:"2px solid rgba(0, 0, 0, 0.5)",borderRadius:"0 2px 2px 0"})},t),o=h(i,{threshold:1}),l=h(s,{threshold:1}),a=r((()=>{const t=o.signal.value;t&&("move"===t.type&&void 0!==t.deltaX?this.onResize(t.deltaX,"start"):"end"===t.type&&this.onEndResizing("start"))}),[o.signal]),d=r((()=>{const t=l.signal.value;t&&("move"===t.type&&void 0!==t.deltaX?this.onResize(t.deltaX,"end"):"end"===t.type&&this.onEndResizing("end"))}),[l.signal]);this.subscriptions.push((()=>{a(),d(),o.cleanup(),l.cleanup()}))}removeResizeHandles(t){const e=t.querySelector('[part*="region-handle-left"]'),i=t.querySelector('[part*="region-handle-right"]');e&&t.removeChild(e),i&&t.removeChild(i)}initElement(){if(this.isRemoved)return null;const t=this.start===this.end;let e=0,i=100;this.channelIdx>=0&&this.numberOfChannels>0&&this.channelIdx<this.numberOfChannels&&(i=100/this.numberOfChannels,e=i*this.channelIdx);const s=n("div",{style:{position:"absolute",top:`${e}%`,height:`${i}%`,backgroundColor:t?"none":this.color,borderLeft:t?"2px solid "+this.color:"none",borderRadius:"2px",boxSizing:"border-box",transition:"background-color 0.2s ease",cursor:this.drag?"grab":"default",pointerEvents:"all"}});return!t&&this.resize&&this.addResizeHandles(s),s}renderPosition(){if(!this.element)return;const t=this.start/this.totalDuration,e=(this.totalDuration-this.end)/this.totalDuration;this.element.style.left=100*t+"%",this.element.style.right=100*e+"%"}toggleCursor(t){var e;this.drag&&(null===(e=this.element)||void 0===e?void 0:e.style)&&(this.element.style.cursor=t?"grabbing":"grab")}initMouseEvents(){const{element:t}=this;if(!t)return;const e=o(t,"click"),i=o(t,"mouseenter"),n=o(t,"mouseleave"),s=o(t,"dblclick"),a=o(t,"pointerdown"),d=o(t,"pointerup"),c=e.subscribe((t=>t&&this.emit("click",t))),u=i.subscribe((t=>t&&this.emit("over",t))),v=n.subscribe((t=>t&&this.emit("leave",t))),p=s.subscribe((t=>t&&this.emit("dblclick",t))),g=a.subscribe((t=>t&&this.toggleCursor(!0))),m=d.subscribe((t=>t&&this.toggleCursor(!1)));this.subscriptions.push((()=>{c(),u(),v(),p(),g(),m(),l(e),l(i),l(n),l(s),l(a),l(d)}));const f=h(t),b=r((()=>{const t=f.signal.value;t&&("start"===t.type?this.toggleCursor(!0):"move"===t.type&&void 0!==t.deltaX?this.onMove(t.deltaX):"end"===t.type&&(this.toggleCursor(!1),this.drag&&this.emit("update-end")))}),[f.signal]);this.subscriptions.push((()=>{b(),f.cleanup()})),this.contentEditable&&this.content&&(this.contentClickListener=t=>this.onContentClick(t),this.contentBlurListener=()=>this.onContentBlur(),this.content.addEventListener("click",this.contentClickListener),this.content.addEventListener("blur",this.contentBlurListener))}_onUpdate(t,e,i){var n;if(!(null===(n=this.element)||void 0===n?void 0:n.parentElement))return;const{width:s}=this.element.parentElement.getBoundingClientRect(),r=t/s*this.totalDuration;let o=e&&"start"!==e?this.start:this.start+r,l=e&&"end"!==e?this.end:this.end+r;const h=void 0!==i;h&&this.updatingSide&&this.updatingSide!==e&&("start"===this.updatingSide?o=i:l=i),o=Math.max(0,o),l=Math.min(this.totalDuration,l);const a=l-o;this.updatingSide=e;const d=a>=this.minLength&&a<=this.maxLength;o<=l&&(d||h)&&(this.start=o,this.end=l,this.renderPosition(),this.emit("update",e))}onMove(t){this.drag&&this._onUpdate(t)}onResize(t,e){this.resize&&(this.resizeStart||"start"!==e)&&(this.resizeEnd||"end"!==e)&&this._onUpdate(t,e)}onEndResizing(t){this.resize&&(this.emit("update-end",t),this.updatingSide=void 0)}onContentClick(t){t.stopPropagation();t.target.focus(),this.emit("click",t)}onContentBlur(){this.emit("update-end")}_setTotalDuration(t){this.totalDuration=t,this.renderPosition()}play(t){this.emit("play",t&&this.end!==this.start?this.end:void 0)}getContent(t=!1){var e;return t?this.content||void 0:this.element instanceof HTMLElement?(null===(e=this.content)||void 0===e?void 0:e.innerHTML)||void 0:""}setContent(t){var e;if(this.element)if(this.content&&this.contentEditable&&(this.contentClickListener&&this.content.removeEventListener("click",this.contentClickListener),this.contentBlurListener&&this.content.removeEventListener("blur",this.contentBlurListener)),null===(e=this.content)||void 0===e||e.remove(),t){if("string"==typeof t){const e=this.start===this.end;this.content=n("div",{style:{padding:`0.2em ${e?.2:.4}em`,display:"inline-block"},textContent:t})}else this.content=t;this.contentEditable&&(this.content.contentEditable="true",this.contentClickListener=t=>this.onContentClick(t),this.contentBlurListener=()=>this.onContentBlur(),this.content.addEventListener("click",this.contentClickListener),this.content.addEventListener("blur",this.contentBlurListener)),this.content.setAttribute("part","region-content"),this.element.appendChild(this.content),this.emit("content-changed")}else this.content=void 0}setOptions(t){var e,i;if(this.element){if(t.color&&(this.color=t.color,this.element.style.backgroundColor=this.color),void 0!==t.drag&&(this.drag=t.drag,this.element.style.cursor=this.drag?"grab":"default"),void 0!==t.start||void 0!==t.end){const n=this.start===this.end;this.start=this.clampPosition(null!==(e=t.start)&&void 0!==e?e:this.start),this.end=this.clampPosition(null!==(i=t.end)&&void 0!==i?i:n?this.start:this.end),this.renderPosition(),this.setPart()}if(t.content&&this.setContent(t.content),t.id&&(this.id=t.id,this.setPart()),void 0!==t.resize&&t.resize!==this.resize){const e=this.start===this.end;this.resize=t.resize,this.resize&&!e?this.addResizeHandles(this.element):this.removeResizeHandles(this.element)}void 0!==t.resizeStart&&(this.resizeStart=t.resizeStart),void 0!==t.resizeEnd&&(this.resizeEnd=t.resizeEnd)}}remove(){this.isRemoved=!0,this.emit("remove"),this.subscriptions.forEach((t=>t())),this.subscriptions=[],this.content&&this.contentEditable&&(this.contentClickListener&&(this.content.removeEventListener("click",this.contentClickListener),this.contentClickListener=void 0),this.contentBlurListener&&(this.content.removeEventListener("blur",this.contentBlurListener),this.contentBlurListener=void 0)),this.element&&(this.element.remove(),this.element=null),this.unAll()}}class d extends e{constructor(t){super(t),this.regions=[],this.regionsContainer=this.initRegionsContainer()}static create(t){return new d(t)}onInit(){if(!this.wavesurfer)throw Error("WaveSurfer is not initialized");this.wavesurfer.getWrapper().appendChild(this.regionsContainer),this.subscriptions.push(this.wavesurfer.on("ready",(t=>{this.regions.forEach((e=>e._setTotalDuration(t)))})));let t=[];this.subscriptions.push(this.wavesurfer.on("timeupdate",(e=>{const i=this.regions.filter((t=>t.start<=e&&(t.end===t.start?t.start+.05:t.end)>=e));i.forEach((e=>{t.includes(e)||this.emit("region-in",e)})),t.forEach((t=>{i.includes(t)||this.emit("region-out",t)})),t=i})))}initRegionsContainer(){return n("div",{part:"regions-container",style:{position:"absolute",top:"0",left:"0",width:"100%",height:"100%",zIndex:"5",pointerEvents:"none"}})}getRegions(){return this.regions}avoidOverlapping(t){t.content&&setTimeout((()=>{const e=t.content,i=e.getBoundingClientRect(),n=this.regions.map((e=>{if(e===t||!e.content)return 0;const n=e.content.getBoundingClientRect();return i.left<n.left+n.width&&n.left<i.left+i.width?n.height:0})).reduce(((t,e)=>t+e),0);e.style.marginTop=`${n}px`}),10)}adjustScroll(t){var e,i;if(!t.element)return;const n=null===(i=null===(e=this.wavesurfer)||void 0===e?void 0:e.getWrapper())||void 0===i?void 0:i.parentElement;if(!n)return;const{clientWidth:s,scrollWidth:r}=n;if(r<=s)return;const o=n.getBoundingClientRect(),l=t.element.getBoundingClientRect(),h=l.left-o.left,a=l.right-o.left;h<0?n.scrollLeft+=h:a>s&&(n.scrollLeft+=a-s)}virtualAppend(t,e,i){const n=()=>{if(!this.wavesurfer)return;const n=this.wavesurfer.getWidth(),s=this.wavesurfer.getScroll(),r=e.clientWidth,o=this.wavesurfer.getDuration(),l=Math.round(t.start/o*r),h=l+(Math.round((t.end-t.start)/o*r)||1)>s&&l<s+n;h&&!i.parentElement?e.appendChild(i):!h&&i.parentElement&&i.remove()};setTimeout((()=>{if(!this.wavesurfer||!t.element)return;n();const e=this.wavesurfer.on("scroll",n),i=this.wavesurfer.on("zoom",n),s=this.wavesurfer.on("resize",n);this.subscriptions.push(e,i,s),t.once("remove",(()=>{e(),i(),s()}))}),0)}saveRegion(t){if(!t.element)return;this.virtualAppend(t,this.regionsContainer,t.element),this.avoidOverlapping(t),this.regions.push(t);const e=[t.on("update",(e=>{e||this.adjustScroll(t),this.emit("region-update",t,e)})),t.on("update-end",(e=>{this.avoidOverlapping(t),this.emit("region-updated",t,e)})),t.on("play",(e=>{var i;null===(i=this.wavesurfer)||void 0===i||i.play(t.start,e)})),t.on("click",(e=>{this.emit("region-clicked",t,e)})),t.on("dblclick",(e=>{this.emit("region-double-clicked",t,e)})),t.on("content-changed",(()=>{this.emit("region-content-changed",t)})),t.once("remove",(()=>{e.forEach((t=>t())),this.regions=this.regions.filter((e=>e!==t)),this.emit("region-removed",t)}))];this.subscriptions.push(...e),this.emit("region-created",t)}addRegion(t){var e,i;if(!this.wavesurfer)throw Error("WaveSurfer is not initialized");const n=this.wavesurfer.getDuration(),s=null===(i=null===(e=this.wavesurfer)||void 0===e?void 0:e.getDecodedData())||void 0===i?void 0:i.numberOfChannels,r=new a(t,n,s);return this.emit("region-initialized",r),n?this.saveRegion(r):this.subscriptions.push(this.wavesurfer.once("ready",(t=>{r._setTotalDuration(t),this.saveRegion(r)}))),r}enableDragSelection(t,e=3){var i;const n=null===(i=this.wavesurfer)||void 0===i?void 0:i.getWrapper();if(!(n&&n instanceof HTMLElement))return()=>{};let s=null,o=0,l=0;const d=h(n,{threshold:e}),c=r((()=>{var e,i;const n=d.signal.value;if(n)if("start"===n.type){if(o=n.x,!this.wavesurfer)return;const r=this.wavesurfer.getDuration(),h=null===(i=null===(e=this.wavesurfer)||void 0===e?void 0:e.getDecodedData())||void 0===i?void 0:i.numberOfChannels,{width:d}=this.wavesurfer.getWrapper().getBoundingClientRect();l=o/d*r;const c=n.x/d*r,u=(n.x+5)/d*r;s=new a(Object.assign(Object.assign({},t),{start:c,end:u}),r,h),this.emit("region-initialized",s),s.element&&this.regionsContainer.appendChild(s.element)}else"move"===n.type&&void 0!==n.deltaX?s&&s._onUpdate(n.deltaX,n.x>o?"end":"start",l):"end"===n.type&&s&&(this.saveRegion(s),s.updatingSide=void 0,s=null)}),[d.signal]);return()=>{c(),d.cleanup()}}clearRegions(){this.regions.slice().forEach((t=>t.remove())),this.regions=[]}destroy(){this.clearRegions(),super.destroy(),this.regionsContainer.remove()}}return d}));</script>
        <style>
            /* V3.0 - Theme Variables */
            :root {
                --bg-primary: #0a0a0a;
                --bg-secondary: #1a1a1a;
                --bg-tertiary: #282828;
                --bg-card: #1e1e1e;
                --text-primary: #ffffff;
                --text-secondary: #b3b3b3;
                --text-muted: #666666;
                --accent: #1db954;
                --accent-hover: #1ed760;
                --border-color: #404040;
                --border-accent: #1db954;
                --shadow: rgba(0, 0, 0, 0.3);
                --waveform-bg: #1a1a1a;
                --waveform-wave: #1db954;
                --waveform-progress: #1ed760;
            }

            /* Light Theme */
            [data-theme="light"] {
                --bg-primary: #f5f5f5;
                --bg-secondary: #ffffff;
                --bg-tertiary: #e8e8e8;
                --bg-card: #ffffff;
                --text-primary: #1a1a1a;
                --text-secondary: #4a4a4a;
                --text-muted: #888888;
                --accent: #1db954;
                --accent-hover: #1ed760;
                --border-color: #d0d0d0;
                --border-accent: #1db954;
                --shadow: rgba(0, 0, 0, 0.1);
                --waveform-bg: #e8e8e8;
                --waveform-wave: #1db954;
                --waveform-progress: #1ed760;
            }

            /* Blue Theme */
            [data-theme="blue"] {
                --bg-primary: #0a1628;
                --bg-secondary: #0f2744;
                --bg-tertiary: #1a3a5c;
                --bg-card: #0f2744;
                --text-primary: #ffffff;
                --text-secondary: #a8c5e2;
                --text-muted: #5a7a9a;
                --accent: #3b82f6;
                --accent-hover: #60a5fa;
                --border-color: #1e4976;
                --border-accent: #3b82f6;
                --shadow: rgba(0, 0, 0, 0.4);
                --waveform-bg: #0f2744;
                --waveform-wave: #3b82f6;
                --waveform-progress: #60a5fa;
            }

            /* Purple Theme */
            [data-theme="purple"] {
                --bg-primary: #1a0a28;
                --bg-secondary: #2d1344;
                --bg-tertiary: #3d1a5c;
                --bg-card: #2d1344;
                --text-primary: #ffffff;
                --text-secondary: #d4a8e2;
                --text-muted: #8a5a9a;
                --accent: #a855f7;
                --accent-hover: #c084fc;
                --border-color: #4e1e76;
                --border-accent: #a855f7;
                --shadow: rgba(0, 0, 0, 0.4);
                --waveform-bg: #2d1344;
                --waveform-wave: #a855f7;
                --waveform-progress: #c084fc;
            }

            /* Orange Theme */
            [data-theme="orange"] {
                --bg-primary: #1a1008;
                --bg-secondary: #2d1f0f;
                --bg-tertiary: #442d14;
                --bg-card: #2d1f0f;
                --text-primary: #ffffff;
                --text-secondary: #e2c4a8;
                --text-muted: #9a7a5a;
                --accent: #f97316;
                --accent-hover: #fb923c;
                --border-color: #764e1e;
                --border-accent: #f97316;
                --shadow: rgba(0, 0, 0, 0.4);
                --waveform-bg: #2d1f0f;
                --waveform-wave: #f97316;
                --waveform-progress: #fb923c;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: var(--bg-primary);
                color: var(--text-primary);
                overflow-x: hidden;
                transition:
                    background 0.3s,
                    color 0.3s;
            }

            .container {
                display: flex;
                flex-direction: column;
                height: 100vh;
            }

            .top-bar {
                background: var(--bg-secondary);
                padding: 15px 30px;
                border-bottom: 2px solid var(--accent);
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition:
                    background 0.3s,
                    border-color 0.3s;
            }

            .logo {
                display: flex;
                flex-direction: column;
                gap: 5px;
            }

            .logo h1 {
                font-size: 24px;
                color: var(--accent);
                margin: 0;
            }

            .subtitle {
                font-size: 12px;
                color: var(--text-muted);
                font-weight: normal;
            }

            .controls-top {
                display: flex;
                gap: 10px;
                align-items: center;
            }

            .toggle-container {
                display: flex;
                align-items: center;
                gap: 8px;
                background: #535353;
                padding: 10px 20px;
                border-radius: 20px;
                cursor: pointer;
                transition: all 0.2s;
                border: none;
            }

            .toggle-container:hover {
                background: #636363;
                transform: scale(1.05);
            }

            .toggle-container input[type="checkbox"] {
                width: 16px;
                height: 16px;
                cursor: pointer;
                accent-color: #1db954;
            }

            .toggle-label {
                font-size: 14px;
                color: #fff;
                font-weight: bold;
                user-select: none;
            }

            .toggle-container:has(input:checked) {
                background: rgba(29, 185, 84, 0.3);
            }

            .toggle-container:has(input:checked) .toggle-label {
                color: #1db954;
            }

            .btn {
                padding: 10px 20px;
                border: none;
                border-radius: 20px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
            }

            .btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .btn-primary {
                background: #1db954;
                color: #fff;
            }

            .btn-primary:hover:not(:disabled) {
                background: #1ed760;
                transform: scale(1.05);
            }

            .btn-play {
                background: #1db954;
                color: #fff;
                font-size: 16px;
            }

            .btn-play:hover:not(:disabled) {
                background: #1ed760;
                transform: scale(1.05);
            }

            .btn-success {
                background: #1db954;
                color: #fff;
            }

            .btn-success:hover:not(:disabled) {
                background: #1ed760;
            }

            .btn-warning {
                background: #ff9500;
                color: #fff;
            }

            .btn-warning:hover {
                background: #ffb100;
            }

            .btn-secondary {
                background: #404040;
                color: #fff;
            }

            .btn-secondary:hover {
                background: #505050;
            }

            .btn-danger {
                background: #ff4444;
                color: #fff;
            }

            .btn-danger:hover:not(:disabled) {
                background: #ff6666;
            }

            .btn-icon {
                background: #282828;
                border: none;
                color: #fff;
                padding: 8px 12px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
            }

            .btn-icon:hover {
                background: #383838;
            }

            .editor-main {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                padding: 20px;
                gap: 20px;
            }

            .waveform-section {
                background: #181818;
                border-radius: 10px;
                padding: 20px;
                border: 1px solid #282828;
            }

            .waveform-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }

            .waveform-header h3 {
                font-size: 18px;
                color: #1db954;
            }

            .waveform-info {
                margin-bottom: 15px;
                padding: 10px;
                background: #282828;
                border-radius: 5px;
                border-left: 3px solid #1db954;
            }

            .waveform-info p {
                font-size: 13px;
                color: #b3b3b3;
                margin: 0;
            }

            .waveform-controls {
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .waveform-controls span {
                font-size: 14px;
                color: #b3b3b3;
                font-family: "Courier New", monospace;
            }

            #waveform {
                min-height: 180px;
                background: #0a0a0a;
                border-radius: 5px;
                overflow: hidden;
                cursor: crosshair;
                position: relative; /* V2.2 - For the markers */
            }

            .wavesurfer-region {
                border-left: 3px solid rgba(255, 255, 255, 0.8) !important;
                border-right: 3px solid rgba(255, 255, 255, 0.8) !important;
            }

            .wavesurfer-handle {
                background: rgba(255, 255, 255, 0.95) !important;
                width: 10px !important;
                border-radius: 4px !important;
                cursor: ew-resize !important;
                box-shadow:
                    0 0 8px rgba(0, 0, 0, 0.8),
                    0 0 3px rgba(255, 255, 255, 0.5) !important;
                transition: all 0.2s ease !important;
            }

            .wavesurfer-handle:hover {
                background: #1db954 !important;
                width: 14px !important;
                box-shadow:
                    0 0 12px rgba(29, 185, 84, 0.8),
                    0 0 5px rgba(255, 255, 255, 0.8) !important;
            }

            /* V2.2 - TOOLTIP VERY LISIBLE for resize */
            .resize-tooltip {
                position: fixed;
                background: linear-gradient(135deg, #1db954 0%, #1ed760 100%);
                color: #000;
                padding: 15px 25px;
                border-radius: 12px;
                font-family: "Courier New", monospace;
                font-size: 20px;
                font-weight: bold;
                pointer-events: none;
                z-index: 99999;
                border: 4px solid #fff;
                box-shadow:
                    0 8px 32px rgba(0, 0, 0, 0.9),
                    0 0 40px rgba(29, 185, 84, 0.8),
                    0 0 80px rgba(29, 185, 84, 0.5),
                    inset 0 2px 10px rgba(255, 255, 255, 0.3);
                white-space: nowrap;
                opacity: 0;
                visibility: hidden;
                transition:
                    opacity 0.1s ease-out,
                    visibility 0s linear 0.1s;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                letter-spacing: 1px;
                transform: translateX(-50%);
                animation: pulse 0.3s ease-in-out infinite alternate;
            }

            @keyframes pulse {
                from {
                    transform: translateX(-50%) scale(1);
                }
                to {
                    transform: translateX(-50%) scale(1.05);
                }
            }

            .resize-tooltip.visible {
                opacity: 1;
                visibility: visible;
                transition:
                    opacity 0.1s ease-out,
                    visibility 0s linear 0s;
            }

            .resize-tooltip::after {
                content: "";
                position: absolute;
                bottom: -12px;
                left: 50%;
                transform: translateX(-50%);
                width: 0;
                height: 0;
                border-left: 12px solid transparent;
                border-right: 12px solid transparent;
                border-top: 12px solid #fff;
                filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
            }

            .region-duration-overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(29, 185, 84, 0.95);
                color: #000;
                padding: 4px 10px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
                font-family: "Courier New", monospace;
                pointer-events: none;
                z-index: 100;
                white-space: nowrap;
            }

            /* V2.1 - Snap-to-grid styles */
            /* V3.0 - Custom Dropdown (for snap, track, etc.) */
            .custom-dropdown {
                position: relative;
                display: inline-block;
            }

            .custom-dropdown-btn {
                background: #535353;
                border: none;
                border-radius: 20px;
                padding: 10px 20px;
                color: #fff;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .custom-dropdown-btn:hover {
                background: #636363;
                transform: scale(1.05);
            }

            .custom-dropdown-btn .dropdown-icon {
                font-size: 14px;
            }

            .custom-dropdown-btn .dropdown-label {
                font-size: 14px;
            }

            .custom-dropdown-menu {
                position: absolute;
                top: calc(100% + 8px);
                left: 0;
                background: #282828;
                border: 1px solid #404040;
                border-radius: 12px;
                padding: 8px;
                min-width: 200px;
                opacity: 0;
                visibility: hidden;
                transform: translateY(-10px);
                transition: all 0.2s ease;
                z-index: 1000;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            }

            .custom-dropdown.active .custom-dropdown-menu {
                opacity: 1;
                visibility: visible;
                transform: translateY(0);
            }

            .dropdown-option {
                display: flex;
                flex-direction: column;
                padding: 10px 15px;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.15s;
            }

            .dropdown-option:hover {
                background: #333;
            }

            .dropdown-option.active {
                background: rgba(29, 185, 84, 0.2);
            }

            .dropdown-option .option-name {
                font-size: 14px;
                font-weight: bold;
                color: #fff;
            }

            .dropdown-option.active .option-name {
                color: #1db954;
            }

            .dropdown-option .option-desc {
                font-size: 11px;
                color: #888;
                margin-top: 2px;
            }

            /* Track selector row */
            .track-selector-row {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 15px;
            }

            .track-selector-row label {
                font-size: 14px;
                color: #b3b3b3;
                font-weight: bold;
            }

            /* V2.1 - Batch editing modal */
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.85);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.2s ease;
            }

            .modal-overlay.active {
                display: flex;
            }

            @keyframes fadeIn {
                from {
                    opacity: 0;
                }
                to {
                    opacity: 1;
                }
            }

            .modal-content {
                background: #1a1a1a;
                border-radius: 10px;
                padding: 30px;
                max-width: 600px;
                width: 90%;
                border: 2px solid #1db954;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
                animation: slideUp 0.3s ease;
            }

            @keyframes slideUp {
                from {
                    transform: translateY(50px);
                    opacity: 0;
                }
                to {
                    transform: translateY(0);
                    opacity: 1;
                }
            }

            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 25px;
                padding-bottom: 15px;
                border-bottom: 2px solid #282828;
            }

            .modal-header h2 {
                color: #1db954;
                font-size: 22px;
                margin: 0;
            }

            .modal-close {
                background: none;
                border: none;
                color: #b3b3b3;
                font-size: 28px;
                cursor: pointer;
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: color 0.2s;
            }

            .modal-close:hover {
                color: #ff4444;
            }

            .batch-tabs {
                display: flex;
                gap: 10px;
                margin-bottom: 20px;
            }

            .batch-tab {
                flex: 1;
                padding: 10px 15px;
                background: #282828;
                border: none;
                border-radius: 5px;
                color: #b3b3b3;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                transition: all 0.2s;
            }

            .batch-tab.active {
                background: #1db954;
                color: #000;
            }

            .batch-tab:hover:not(.active) {
                background: #333;
            }

            .batch-panel {
                display: none;
            }

            .batch-panel.active {
                display: block;
            }

            .batch-stats {
                background: rgba(29, 185, 84, 0.1);
                border: 1px solid #1db954;
                border-radius: 5px;
                padding: 15px;
                margin-bottom: 20px;
            }

            .batch-stats p {
                margin: 5px 0;
                font-size: 13px;
                color: #b3b3b3;
            }

            .batch-stats strong {
                color: #1db954;
            }

            /* V2.2 - Waveform Markers/Bookmarks */
            .waveform-marker {
                position: absolute;
                top: 0;
                bottom: 0;
                width: 3px;
                --marker-color: #ff6b6b;
                background: var(--marker-color);
                cursor: pointer;
                z-index: 50;
                transition: all 0.2s;
            }

            .waveform-marker:hover {
                width: 5px;
                filter: brightness(1.2);
            }

            .waveform-marker::before {
                content: "ðŸ“";
                position: absolute;
                top: -25px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 16px;
                filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
                pointer-events: none;
            }

            .marker-delete-btn {
                position: absolute;
                top: 5px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 68, 68, 0.9);
                color: #fff;
                border: none;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                font-size: 12px;
                cursor: pointer;
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 100;
                transition: all 0.2s;
                padding: 0;
                line-height: 1;
            }

            .waveform-marker:hover .marker-delete-btn {
                display: flex;
            }

            .marker-delete-btn:hover {
                background: rgba(255, 68, 68, 1);
                transform: translateX(-50%) scale(1.1);
            }

            .marker-tooltip {
                position: fixed;
                background: rgba(255, 107, 107, 0.95);
                color: #fff;
                padding: 6px 10px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
                pointer-events: none;
                z-index: 10000;
                white-space: nowrap;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            }

            /* V2.2 - Multi-Track Support */
            .track-selector {
                display: flex;
                align-items: center;
                gap: 10px;
                background: #282828;
                padding: 10px 15px;
                border-radius: 8px;
                margin-bottom: 15px;
                border: 1px solid #404040;
            }

            .track-selector label {
                font-size: 13px;
                color: #b3b3b3;
                font-weight: bold;
            }

            .track-select {
                background: #181818;
                border: 1px solid #404040;
                border-radius: 5px;
                padding: 6px 10px;
                color: #1db954;
                font-size: 13px;
                font-weight: bold;
                cursor: pointer;
                outline: none;
                transition: border-color 0.2s;
                min-width: 150px;
            }

            .track-select:focus {
                border-color: #1db954;
            }

            .track-indicator {
                display: inline-block;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                margin-right: 8px;
            }

            .track-actions {
                display: flex;
                gap: 5px;
            }

            /* V2.2 - Track Management Modal */
            .track-modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.85);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            }

            .track-modal.active {
                display: flex;
            }

            .track-modal-content {
                background: #1a1a1a;
                border-radius: 10px;
                padding: 25px;
                max-width: 500px;
                width: 90%;
                border: 2px solid #1db954;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            }

            .track-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
                margin: 20px 0;
                max-height: 300px;
                overflow-y: auto;
            }

            .track-item {
                display: flex;
                align-items: center;
                justify-content: space-between;
                background: #282828;
                padding: 12px 15px;
                border-radius: 5px;
                border: 2px solid transparent;
                transition: all 0.2s;
            }

            .track-item.active {
                border-color: #1db954;
                background: rgba(29, 185, 84, 0.1);
            }

            .track-item-info {
                display: flex;
                align-items: center;
                gap: 10px;
                flex: 1;
            }

            .track-item-name {
                color: #fff;
                font-weight: bold;
                font-size: 14px;
            }

            .track-item-count {
                color: #666;
                font-size: 12px;
            }

            .track-item-actions {
                display: flex;
                gap: 5px;
            }

            .editor-section {
                flex: 1;
                display: grid;
                grid-template-columns: 400px 1fr 350px;
                gap: 20px;
                overflow: hidden;
            }

            .lyrics-section {
                background: #181818;
                border-radius: 10px;
                padding: 20px;
                border: 1px solid #282828;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .lyrics-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .lyrics-header h3 {
                font-size: 18px;
                color: #1db954;
            }

            .lyrics-content {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden; /* V3.0 - No horizontal scroll */
                display: flex;
                flex-direction: column;
                gap: 15px;
                padding-right: 10px;
            }

            .lyric-line {
                padding: 12px;
                border-radius: 5px;
                background: #282828;
                border-left: 3px solid #404040;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .lyric-line:hover {
                background: #333;
                border-left-color: #1db954;
            }

            .lyric-line.active {
                background: rgba(29, 185, 84, 0.15);
                border-left-color: #1db954;
                transform: translateX(5px);
            }

            .lyric-time {
                font-size: 11px;
                color: #666;
                font-family: "Courier New", monospace;
                margin-bottom: 5px;
            }

            .lyric-text {
                color: #fff;
                font-size: 15px;
                line-height: 1.6;
            }

            .lyric-line.active .lyric-text {
                color: #1db954;
                font-weight: bold;
            }

            .cue-editor {
                background: #181818;
                border-radius: 10px;
                padding: 20px;
                border: 1px solid #282828;
                overflow-y: auto;
            }

            .cue-editor h3 {
                font-size: 18px;
                color: #1db954;
                margin-bottom: 15px;
            }

            .cue-form {
                display: flex;
                flex-direction: column;
                gap: 15px;
            }

            .form-row {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
            }

            .form-group {
                display: flex;
                flex-direction: column;
                gap: 5px;
                flex: 1;
                min-width: 120px;
            }

            .form-group label {
                font-size: 12px;
                color: #b3b3b3;
                font-weight: bold;
            }

            .form-group input,
            .form-group textarea {
                background: #282828;
                border: 1px solid #404040;
                border-radius: 5px;
                padding: 10px;
                color: #fff;
                font-size: 14px;
                font-family: inherit;
                outline: none;
                transition: border-color 0.2s;
            }

            .form-group input:focus,
            .form-group textarea:focus {
                border-color: #1db954;
            }

            .form-group textarea {
                resize: vertical;
            }

            .mark-buttons {
                display: flex;
                flex-direction: row;
                gap: 5px;
                align-items: flex-end;
            }

            .mark-buttons button {
                flex: 1;
                padding: 8px 10px;
                font-size: 12px;
            }

            .color-picker {
                display: flex;
                gap: 10px;
                align-items: center;
            }

            .color-picker input[type="color"] {
                width: 60px;
                height: 40px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                background: transparent;
            }

            .color-picker input[type="color"]::-webkit-color-swatch-wrapper {
                padding: 0;
            }

            .color-picker input[type="color"]::-webkit-color-swatch {
                border: 2px solid #404040;
                border-radius: 5px;
            }

            .cue-actions {
                display: flex;
                gap: 10px;
                margin-top: 10px;
                flex-wrap: wrap;
            }

            .cue-actions button {
                flex: 1;
                min-width: 100px;
            }

            .cues-list-section {
                background: #181818;
                border-radius: 10px;
                padding: 20px;
                border: 1px solid #282828;
                display: flex;
                flex-direction: column;
                overflow: hidden; /* V3.0 - Prevent any overflow */
            }

            .cues-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .cues-header h3 {
                font-size: 18px;
                color: #1db954;
            }

            .cues-list {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden; /* V3.0 - No horizontal scroll */
                display: flex;
                flex-direction: column;
                gap: 10px;
                max-height: calc(100vh - 600px);
                min-height: 300px;
            }

            .no-cues {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 100%;
                color: #666;
                font-style: italic;
            }

            .cue-item {
                background: #282828;
                border-radius: 5px;
                padding: 12px;
                border: 2px solid transparent;
                cursor: pointer;
                transition: all 0.2s;
                position: relative;
            }

            .cue-item::before {
                content: "";
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                width: 4px;
                background: var(--cue-color, #1db954);
                border-radius: 5px 0 0 5px;
            }

            .cue-item:hover {
                background: #333;
                border-color: #404040;
            }

            .cue-item.active {
                border-color: var(--cue-color, #1db954);
                background: rgba(29, 185, 84, 0.1);
            }

            .cue-item.overlap {
                border-color: #ff4444;
                background: rgba(255, 68, 68, 0.1);
            }

            .cue-item-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            }

            .cue-header-right {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .cue-number {
                font-weight: bold;
                color: var(--cue-color, #1db954);
                font-size: 14px;
            }

            .cue-time {
                font-size: 11px;
                color: #b3b3b3;
                font-family: "Courier New", monospace;
            }

            .cue-text {
                color: #fff;
                font-size: 14px;
                line-height: 1.5;
                margin-bottom: 8px;
            }

            .cue-warning {
                background: rgba(255, 68, 68, 0.2);
                color: #ff6666;
                padding: 5px 8px;
                border-radius: 3px;
                font-size: 11px;
                margin-bottom: 8px;
                display: flex;
                align-items: center;
                gap: 5px;
            }

            .cue-actions-row {
                display: flex;
                gap: 5px;
            }

            .cue-actions-row button {
                padding: 5px 10px;
                font-size: 12px;
                border-radius: 5px;
            }

            .shortcuts-bar {
                background: #1a1a1a;
                border-top: 1px solid #282828;
                padding: 10px 30px;
                display: flex;
                gap: 20px;
                flex-wrap: wrap;
            }

            .shortcut {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 12px;
                color: #b3b3b3;
            }

            .shortcut kbd {
                background: #282828;
                padding: 4px 8px;
                border-radius: 3px;
                border: 1px solid #404040;
                font-family: "Courier New", monospace;
                font-size: 11px;
                color: #1db954;
            }

            .toast-container {
                position: fixed;
                top: 80px;
                right: 20px;
                z-index: 9999;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .toast {
                background: #282828;
                border-radius: 8px;
                padding: 15px 20px;
                min-width: 300px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                gap: 12px;
                animation: slideIn 0.3s ease;
                border-left: 4px solid #1db954;
            }

            .toast.success {
                border-left-color: #1db954;
            }

            .toast.error {
                border-left-color: #ff4444;
            }

            .toast.warning {
                border-left-color: #ff9500;
            }

            .toast.info {
                border-left-color: #54a0ff;
            }

            .toast-icon {
                font-size: 20px;
                flex-shrink: 0;
            }

            .toast-content {
                flex: 1;
                color: #fff;
                font-size: 14px;
            }

            .toast-close {
                background: none;
                border: none;
                color: #b3b3b3;
                cursor: pointer;
                font-size: 18px;
                padding: 0;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .toast-close:hover {
                color: #fff;
            }

            @keyframes slideIn {
                from {
                    transform: translateX(400px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            ::-webkit-scrollbar {
                width: 10px;
            }

            ::-webkit-scrollbar-track {
                background: #181818;
            }

            ::-webkit-scrollbar-thumb {
                background: #404040;
                border-radius: 5px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: #505050;
            }

            /* V3.0 - Export Dropdown Menu */
            .export-dropdown {
                position: relative;
                display: inline-block;
            }

            .export-dropdown-btn {
                background: #1db954;
                color: #fff;
                padding: 10px 20px;
                border: none;
                border-radius: 20px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .export-dropdown-btn:hover:not(:disabled) {
                background: #1ed760;
                transform: scale(1.05);
            }

            .export-dropdown-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .export-dropdown-btn::after {
                content: "â–¼";
                font-size: 10px;
                transition: transform 0.2s;
            }

            .export-dropdown.active .export-dropdown-btn::after {
                transform: rotate(180deg);
            }

            .export-dropdown-menu {
                position: absolute;
                top: calc(100% + 5px);
                right: 0;
                background: #1a1a1a;
                border: 2px solid #1db954;
                border-radius: 10px;
                min-width: 220px;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
                opacity: 0;
                visibility: hidden;
                transform: translateY(-10px);
                transition: all 0.2s ease;
                z-index: 1000;
                overflow: hidden;
            }

            .export-dropdown.active .export-dropdown-menu {
                opacity: 1;
                visibility: visible;
                transform: translateY(0);
            }

            .export-dropdown-menu button {
                width: 100%;
                padding: 12px 16px;
                background: transparent;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                border: none;
                color: #fff;
                font-size: 14px;
                text-align: left;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 10px;
                transition: background 0.2s;
                margin: 0;
            }

            .export-dropdown-menu button:hover {
                background: rgba(29, 185, 84, 0.2);
            }

            .export-dropdown-menu button:not(:last-child) {
                border-bottom: 1px solid #282828;
            }

            .export-format-icon {
                font-size: 16px;
            }

            .export-format-info {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .export-format-name {
                font-weight: bold;
                color: #1db954;
            }

            .export-format-desc {
                font-size: 11px;
                color: #666;
            }

            /* V3.0 - Import Dropdown Menu */
            .import-dropdown {
                position: relative;
                display: inline-block;
            }

            .import-dropdown-btn {
                background: #404040;
                color: #fff;
                padding: 10px 20px;
                border: none;
                border-radius: 20px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .import-dropdown-btn:hover {
                background: #505050;
                transform: scale(1.05);
            }

            .import-dropdown-btn::after {
                content: "â–¼";
                font-size: 10px;
                transition: transform 0.2s;
            }

            .import-dropdown.active .import-dropdown-btn::after {
                transform: rotate(180deg);
            }

            .import-dropdown-menu {
                position: absolute;
                top: calc(100% + 5px);
                left: 0;
                background: #1a1a1a;
                border: 2px solid #404040;
                border-radius: 10px;
                min-width: 220px;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
                opacity: 0;
                visibility: hidden;
                transform: translateY(-10px);
                transition: all 0.2s ease;
                z-index: 1000;
                overflow: hidden;
            }

            .import-dropdown.active .import-dropdown-menu {
                opacity: 1;
                visibility: visible;
                transform: translateY(0);
            }

            .import-dropdown-menu label,
            .import-dropdown-menu button {
                width: 100%;
                padding: 12px 16px;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: transparent;
                border: none;
                color: #fff;
                font-size: 14px;
                text-align: left;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 10px;
                transition: background 0.2s;
                margin: 0;
            }

            .import-dropdown-menu label:hover,
            .import-dropdown-menu button:hover {
                background: rgba(64, 64, 64, 0.5);
            }

            .import-dropdown-menu label:not(:last-child),
            .import-dropdown-menu button:not(:last-child) {
                border-bottom: 1px solid #282828;
            }

            .import-format-icon {
                font-size: 16px;
            }

            .import-format-info {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .import-format-name {
                font-weight: bold;
                color: #b3b3b3;
            }

            .import-format-desc {
                font-size: 11px;
                color: #666;
            }

            .import-dropdown-menu label input[type="file"] {
                display: none;
            }

            /* V3.0 - Advanced Editing Tools */
            .advanced-edit-section {
                margin-top: 15px;
                padding-top: 15px;
                border-top: 1px solid #282828;
            }

            .advanced-edit-section h4 {
                font-size: 13px;
                color: #b3b3b3;
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .advanced-edit-buttons {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }

            .btn-edit-tool {
                padding: 8px 12px;
                background: #282828;
                border: 1px solid #404040;
                border-radius: 8px;
                color: #b3b3b3;
                font-size: 12px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .btn-edit-tool:hover:not(:disabled) {
                background: #333;
                border-color: #1db954;
                color: #fff;
            }

            .btn-edit-tool:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }

            .btn-edit-tool.split:hover:not(:disabled) {
                border-color: #54a0ff;
                color: #54a0ff;
            }

            .btn-edit-tool.merge:hover:not(:disabled) {
                border-color: #ff9f43;
                color: #ff9f43;
            }

            .btn-edit-tool.shift:hover:not(:disabled) {
                border-color: #a55eea;
                color: #a55eea;
            }

            /* V3.0 - Shift Timings Modal */
            .shift-modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.85);
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            }

            .shift-modal.active {
                display: flex;
            }

            .shift-modal-content {
                background: #1a1a1a;
                border-radius: 10px;
                padding: 25px;
                max-width: 400px;
                width: 90%;
                border: 2px solid #a55eea;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
                animation: slideUp 0.3s ease;
            }

            .shift-preview {
                background: #282828;
                border-radius: 8px;
                padding: 15px;
                margin: 15px 0;
                text-align: center;
            }

            .shift-preview-value {
                font-size: 32px;
                font-weight: bold;
                font-family: "Courier New", monospace;
                color: #a55eea;
                margin-bottom: 5px;
            }

            .shift-preview-value.positive {
                color: #1db954;
            }

            .shift-preview-value.negative {
                color: #ff6b6b;
            }

            .shift-preview-label {
                font-size: 12px;
                color: #666;
            }

            .shift-controls {
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: center;
                margin: 15px 0;
            }

            .shift-btn {
                width: 45px;
                height: 45px;
                border-radius: 50%;
                border: 2px solid #404040;
                background: #282828;
                color: #fff;
                font-size: 18px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .shift-btn:hover {
                background: #333;
                border-color: #a55eea;
            }

            .shift-btn.minus:hover {
                border-color: #ff6b6b;
                color: #ff6b6b;
            }

            .shift-btn.plus:hover {
                border-color: #1db954;
                color: #1db954;
            }

            .shift-input-group {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .shift-input {
                width: 100px;
                padding: 10px;
                background: #181818;
                border: 2px solid #404040;
                border-radius: 8px;
                color: #fff;
                font-size: 16px;
                font-family: "Courier New", monospace;
                text-align: center;
                outline: none;
            }

            .shift-input:focus {
                border-color: #a55eea;
            }

            .shift-unit {
                color: #666;
                font-size: 14px;
            }

            .shift-quick-btns {
                display: flex;
                gap: 8px;
                justify-content: center;
                margin: 15px 0;
                flex-wrap: wrap;
            }

            .shift-quick-btn {
                padding: 6px 12px;
                background: #282828;
                border: 1px solid #404040;
                border-radius: 5px;
                color: #b3b3b3;
                font-size: 12px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .shift-quick-btn:hover {
                background: #333;
                border-color: #a55eea;
                color: #fff;
            }

            /* V3.0 - Search & Navigation */
            .search-box {
                display: flex;
                gap: 8px;
                margin-bottom: 15px;
            }

            .search-input {
                flex: 1;
                padding: 10px 15px;
                padding-left: 35px;
                background: #282828;
                border: 1px solid #404040;
                border-radius: 20px;
                color: #fff;
                font-size: 13px;
                outline: none;
                transition: all 0.2s;
            }

            .search-input:focus {
                border-color: #1db954;
                background: #1a1a1a;
            }

            .search-input::placeholder {
                color: #666;
            }

            .search-wrapper {
                position: relative;
                flex: 1;
            }

            .search-icon {
                position: absolute;
                left: 12px;
                top: 50%;
                transform: translateY(-50%);
                color: #666;
                font-size: 14px;
                pointer-events: none;
            }

            .search-clear {
                position: absolute;
                right: 10px;
                top: 50%;
                transform: translateY(-50%);
                background: none;
                border: none;
                color: #666;
                font-size: 16px;
                cursor: pointer;
                padding: 0;
                width: 20px;
                height: 20px;
                display: none;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                transition: all 0.2s;
            }

            .search-clear:hover {
                color: #ff4444;
                background: rgba(255, 68, 68, 0.1);
            }

            .search-clear.visible {
                display: flex;
            }

            .search-results-count {
                font-size: 11px;
                color: #666;
                padding: 5px 0;
                text-align: right;
            }

            .search-results-count.has-results {
                color: #1db954;
            }

            .cue-item.search-hidden {
                display: none;
            }

            .cue-item .search-highlight {
                background: rgba(29, 185, 84, 0.4);
                color: #fff;
                padding: 1px 2px;
                border-radius: 2px;
            }

            /* Go to time */
            .goto-time-container {
                display: flex;
                align-items: center;
                gap: 8px;
                background: #282828;
                padding: 6px 12px;
                border-radius: 8px;
                border: 1px solid #404040;
            }

            .goto-time-container:focus-within {
                border-color: #1db954;
            }

            .goto-time-input {
                width: 90px;
                padding: 5px 8px;
                background: #181818;
                border: none;
                border-radius: 4px;
                color: #fff;
                font-size: 13px;
                font-family: "Courier New", monospace;
                text-align: center;
                outline: none;
            }

            .goto-time-input::placeholder {
                color: #555;
                font-size: 11px;
            }

            .goto-time-btn {
                background: #1db954;
                border: none;
                color: #000;
                padding: 5px 10px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
            }

            .goto-time-btn:hover {
                background: #1ed760;
            }

            .goto-time-label {
                font-size: 12px;
                color: #666;
            }

            /* Stats Button & Modal */
            .btn-stats {
                background: #535353;
                border: none;
                border-radius: 20px;
                color: #fff;
                padding: 10px 20px;
                font-size: 14px;
                font-weight: bold;
            }

            .btn-stats:hover {
                background: #636363;
                transform: scale(1.05);
            }

            .cues-header-actions {
                display: flex;
                gap: 8px;
            }

            .stats-modal-content {
                max-width: 500px;
            }

            .stats-modal-content .validation-section {
                margin-top: 20px;
                padding-top: 15px;
                border-top: 1px solid #282828;
            }

            .stats-rules {
                margin-top: 20px;
                padding-top: 15px;
                border-top: 1px solid #282828;
            }

            .stats-rules h4 {
                margin: 0 0 10px 0;
                font-size: 13px;
                color: #888;
            }

            .stats-rules ul {
                list-style: none;
                padding: 0;
                margin: 0;
                font-size: 12px;
                color: #666;
            }

            .stats-rules li {
                padding: 4px 0;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .rule-error {
                background: rgba(231, 76, 60, 0.2);
                color: #e74c3c;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 10px;
                font-weight: bold;
            }

            .rule-warning {
                background: rgba(241, 196, 15, 0.2);
                color: #f1c40f;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 10px;
                font-weight: bold;
            }

            .stats-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 12px;
            }

            .stat-item {
                background: #0d1b2a;
                border-radius: 8px;
                padding: 12px;
                text-align: center;
                transition:
                    transform 0.2s,
                    box-shadow 0.2s;
            }

            .stat-item:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(29, 185, 84, 0.2);
            }

            .stat-value {
                font-size: 24px;
                font-weight: bold;
                color: #1db954;
                display: block;
            }

            .stat-label {
                font-size: 11px;
                color: #888;
                margin-top: 4px;
                display: block;
            }

            .stat-item.warning .stat-value {
                color: #f1c40f;
            }

            .stat-item.error .stat-value {
                color: #e74c3c;
            }

            /* Validation Indicators */
            .validation-section {
                margin-top: 15px;
                padding-top: 15px;
                border-top: 1px solid #0f3460;
            }

            .validation-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 10px;
            }

            .validation-header h4 {
                margin: 0;
                font-size: 12px;
                color: #888;
            }

            .validation-summary {
                display: flex;
                gap: 10px;
            }

            .validation-badge {
                display: flex;
                align-items: center;
                gap: 4px;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 11px;
                font-weight: bold;
            }

            .validation-badge.warnings {
                background: rgba(241, 196, 15, 0.2);
                color: #f1c40f;
            }

            .validation-badge.errors {
                background: rgba(231, 76, 60, 0.2);
                color: #e74c3c;
            }

            .validation-badge.success {
                background: rgba(29, 185, 84, 0.2);
                color: #1db954;
            }

            /* Cue validation indicators */
            .cue-item .validation-icons {
                display: flex;
                gap: 4px;
            }

            .validation-icon {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
                cursor: help;
                position: relative;
            }

            .validation-icon.warning {
                background: rgba(241, 196, 15, 0.2);
                color: #f1c40f;
            }

            .validation-icon.error {
                background: rgba(231, 76, 60, 0.2);
                color: #e74c3c;
            }

            .validation-icon::after {
                content: attr(data-tooltip);
                position: absolute;
                bottom: calc(100% + 5px);
                left: 50%;
                transform: translateX(-50%);
                background: #000;
                color: #fff;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 11px;
                white-space: nowrap;
                opacity: 0;
                visibility: hidden;
                transition: all 0.2s;
                z-index: 100;
            }

            .validation-icon:hover::after {
                opacity: 1;
                visibility: visible;
            }

            .cue-item.has-warning {
                border-left: 3px solid #f1c40f;
            }

            .cue-item.has-error {
                border-left: 3px solid #e74c3c;
            }

            .validation-list {
                display: flex;
                flex-direction: column;
                gap: 6px;
                max-height: 150px;
                overflow-y: auto;
            }

            .validation-item {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px 10px;
                background: #0d1b2a;
                border-radius: 6px;
                font-size: 12px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .validation-item:hover {
                background: #1a2a3a;
            }

            .validation-item .icon {
                font-size: 14px;
            }

            .validation-item .cue-ref {
                color: #1db954;
                font-weight: bold;
            }

            .validation-item .message {
                color: #888;
                flex: 1;
            }

            /* Theme Selector */
            .theme-selector {
                position: relative;
                display: inline-block;
            }

            .theme-btn {
                background: #535353;
                border: none;
                color: #fff;
                padding: 10px 20px;
                border-radius: 20px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                display: flex;
                align-items: center;
                gap: 6px;
                transition: all 0.2s;
            }

            .theme-btn:hover {
                background: #636363;
                transform: scale(1.05);
            }

            .theme-dropdown {
                position: absolute;
                top: calc(100% + 8px);
                right: 0;
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                border-radius: 12px;
                padding: 8px;
                min-width: 160px;
                opacity: 0;
                visibility: hidden;
                transform: translateY(-10px);
                transition: all 0.2s;
                z-index: 1000;
                box-shadow: 0 8px 24px var(--shadow);
            }

            .theme-selector.active .theme-dropdown {
                opacity: 1;
                visibility: visible;
                transform: translateY(0);
            }

            .theme-option {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 10px 12px;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s;
                color: var(--text-primary);
            }

            .theme-option:hover {
                background: var(--bg-tertiary);
            }

            .theme-option.active {
                background: var(--accent);
                color: #fff;
            }

            .theme-color {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 2px solid var(--border-color);
            }

            .theme-color.dark {
                background: linear-gradient(135deg, #1db954, #0a0a0a);
            }
            .theme-color.light {
                background: linear-gradient(135deg, #1db954, #f5f5f5);
            }
            .theme-color.blue {
                background: linear-gradient(135deg, #3b82f6, #0a1628);
            }
            .theme-color.purple {
                background: linear-gradient(135deg, #a855f7, #1a0a28);
            }
            .theme-color.orange {
                background: linear-gradient(135deg, #f97316, #1a1008);
            }

            /* Marker Editor Modal */
            .marker-edit-modal {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
                opacity: 0;
                visibility: hidden;
                transition: all 0.2s;
            }

            .marker-edit-modal.active {
                opacity: 1;
                visibility: visible;
            }

            .marker-edit-content {
                background: var(--bg-secondary);
                border-radius: 16px;
                padding: 25px;
                width: 90%;
                max-width: 400px;
                border: 1px solid var(--border-color);
            }

            .marker-color-picker {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                margin: 15px 0;
            }

            .marker-color-option {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                cursor: pointer;
                border: 3px solid transparent;
                transition: all 0.2s;
            }

            .marker-color-option:hover {
                transform: scale(1.1);
            }

            .marker-color-option.selected {
                border-color: var(--text-primary);
                box-shadow: 0 0 0 2px var(--accent);
            }

            /* Minimap */
            .minimap-container {
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 10px;
                margin-top: 10px;
            }

            .minimap-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 8px;
            }

            .minimap-header h4 {
                font-size: 12px;
                color: var(--text-muted);
                margin: 0;
            }

            .minimap-toggle {
                background: none;
                border: none;
                color: var(--text-muted);
                cursor: pointer;
                font-size: 11px;
                padding: 2px 6px;
                border-radius: 4px;
            }

            .minimap-toggle:hover {
                background: var(--bg-tertiary);
                color: var(--text-primary);
            }

            .minimap {
                height: 40px;
                background: var(--bg-tertiary);
                border-radius: 4px;
                position: relative;
                overflow: hidden;
                cursor: pointer;
            }

            .minimap-region {
                position: absolute;
                height: 100%;
                opacity: 0.7;
                border-radius: 2px;
            }

            .minimap-marker {
                position: absolute;
                width: 2px;
                height: 100%;
                background: #ff6b6b;
            }

            .minimap-viewport {
                position: absolute;
                height: 100%;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid var(--accent);
                border-radius: 2px;
                pointer-events: none;
            }

            .minimap-playhead {
                position: absolute;
                width: 2px;
                height: 100%;
                background: var(--accent);
                z-index: 10;
            }

            @media (max-width: 1200px) {
                .editor-section {
                    grid-template-columns: 1fr;
                }

                .cue-editor {
                    max-width: 100%;
                }

                .lyrics-section {
                    max-height: 400px;
                }

                /* V3.0 - Responsive stats grid */
                .stats-grid {
                    grid-template-columns: repeat(2, 1fr);
                }
            }
        </style>
    </head>
    <body>
        <div class="toast-container" id="toast-container"></div>

        <!-- V2.1 - Batch Edit Modal -->
        <div id="batch-modal" class="modal-overlay">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>ðŸ“ Batch Text Editing</h2>
                    <button class="modal-close" id="close-batch-modal">Ã—</button>
                </div>

                <div class="batch-stats">
                    <p><strong>Total Cues:</strong> <span id="batch-total-cues">0</span></p>
                    <p><strong>Selected Range:</strong> <span id="batch-range">All</span></p>
                </div>

                <div class="batch-tabs">
                    <button class="batch-tab active" data-tab="replace">ðŸ” Find & Replace</button>
                    <button class="batch-tab" data-tab="transform">âœ¨ Transform</button>
                    <button class="batch-tab" data-tab="modify">ðŸ”§ Modify</button>
                </div>

                <!-- Find & Replace Panel -->
                <div id="replace-panel" class="batch-panel active">
                    <div class="form-group">
                        <label>Find Text</label>
                        <input type="text" id="find-text" placeholder="Text to find..." />
                    </div>
                    <div class="form-group">
                        <label>Replace With</label>
                        <input type="text" id="replace-text" placeholder="Replace with..." />
                    </div>
                    <div class="form-group">
                        <label class="toggle-container">
                            <input type="checkbox" id="case-sensitive" />
                            <span class="toggle-label">Case Sensitive</span>
                        </label>
                    </div>
                    <div class="cue-actions">
                        <button id="apply-replace" class="btn btn-primary">ðŸ”„ Replace All</button>
                    </div>
                </div>

                <!-- Transform Panel -->
                <div id="transform-panel" class="batch-panel">
                    <div class="cue-actions" style="flex-direction: column; gap: 10px">
                        <button id="transform-uppercase" class="btn btn-secondary" style="width: 100%">â¬†ï¸ UPPERCASE</button>
                        <button id="transform-lowercase" class="btn btn-secondary" style="width: 100%">â¬‡ï¸ lowercase</button>
                        <button id="transform-capitalize" class="btn btn-secondary" style="width: 100%">ðŸ”¤ Capitalize Each Word</button>
                        <button id="transform-sentence" class="btn btn-secondary" style="width: 100%">ðŸ“ Sentence case</button>
                    </div>
                </div>

                <!-- Modify Panel -->
                <div id="modify-panel" class="batch-panel">
                    <div class="form-group">
                        <label>Add Prefix</label>
                        <input type="text" id="prefix-text" placeholder="Text at start..." />
                    </div>
                    <div class="form-group">
                        <label>Add Suffix</label>
                        <input type="text" id="suffix-text" placeholder="Text at end..." />
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Apply to Cues (Range)</label>
                            <input type="text" id="cue-range" placeholder="Ex: 1-5 ou all" value="all" />
                        </div>
                    </div>
                    <div class="cue-actions">
                        <button id="apply-prefix" class="btn btn-secondary">âž• Add Prefix</button>
                        <button id="apply-suffix" class="btn btn-secondary">âž• Add Suffix</button>
                        <button id="apply-both" class="btn btn-primary">âž• Add Both</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- V2.2 - Track Management Modal -->
        <div id="track-modal" class="track-modal">
            <div class="track-modal-content">
                <div class="modal-header">
                    <h2>ðŸŽ¬ Manage Subtitle Tracks</h2>
                    <button class="modal-close" id="close-track-modal">Ã—</button>
                </div>

                <div class="form-group">
                    <label>Create New Track</label>
                    <div style="display: flex; gap: 10px">
                        <input type="text" id="new-track-name" placeholder="Track name (e.g., English, French, SFX)..." style="flex: 1" />
                        <button id="create-track-btn" class="btn btn-primary">âž• Create</button>
                    </div>
                </div>

                <div class="track-list" id="track-list">
                    <!-- Tracks will be inserted here -->
                </div>

                <div class="batch-stats">
                    <p><strong>Tip:</strong> Use tracks to organize different languages, sound effects, or narrator lines.</p>
                </div>
            </div>
        </div>

        <!-- V3.0 - Shift Timings Modal -->
        <div id="shift-modal" class="shift-modal">
            <div class="shift-modal-content">
                <div class="modal-header">
                    <h2>â±ï¸ Shift All Timings</h2>
                    <button class="modal-close" id="close-shift-modal">Ã—</button>
                </div>

                <p style="color: #b3b3b3; font-size: 13px; margin-bottom: 15px">Offset all cues by Â±X seconds. Useful for synchronizing with audio.</p>

                <div class="shift-preview">
                    <div class="shift-preview-value" id="shift-preview-value">+0.000s</div>
                    <div class="shift-preview-label">Offset to apply</div>
                </div>

                <div class="shift-controls">
                    <button class="shift-btn minus" id="shift-minus-1">-1</button>
                    <button class="shift-btn minus" id="shift-minus-01">-.1</button>
                    <div class="shift-input-group">
                        <input type="number" id="shift-value" class="shift-input" value="0" step="0.001" />
                        <span class="shift-unit">sec</span>
                    </div>
                    <button class="shift-btn plus" id="shift-plus-01">+.1</button>
                    <button class="shift-btn plus" id="shift-plus-1">+1</button>
                </div>

                <div class="shift-quick-btns">
                    <button class="shift-quick-btn" data-value="-5">-5s</button>
                    <button class="shift-quick-btn" data-value="-2">-2s</button>
                    <button class="shift-quick-btn" data-value="-0.5">-0.5s</button>
                    <button class="shift-quick-btn" data-value="0">Reset</button>
                    <button class="shift-quick-btn" data-value="0.5">+0.5s</button>
                    <button class="shift-quick-btn" data-value="2">+2s</button>
                    <button class="shift-quick-btn" data-value="5">+5s</button>
                </div>

                <div class="batch-stats">
                    <p><strong>Cues assigned:</strong> <span id="shift-cues-count">0</span></p>
                </div>

                <div class="cue-actions" style="margin-top: 15px">
                    <button id="apply-shift-btn" class="btn btn-primary">âœ… Apply</button>
                    <button id="cancel-shift-btn" class="btn btn-secondary">âŒ Cancel</button>
                </div>
            </div>
        </div>

        <!-- V3.0 - Stats Modal -->
        <div id="stats-modal" class="modal-overlay">
            <div class="modal-content stats-modal-content">
                <div class="modal-header">
                    <h2>ðŸ“Š Statistics & Validation</h2>
                    <button class="modal-close" id="close-stats-modal">Ã—</button>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="stat-value" id="stat-total-cues">0</span>
                        <span class="stat-label">Cues total</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stat-total-duration">0:00</span>
                        <span class="stat-label">Total duration</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stat-avg-duration">0.0s</span>
                        <span class="stat-label">Average duration</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stat-total-words">0</span>
                        <span class="stat-label">Total words</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stat-wpm">0</span>
                        <span class="stat-label">Words/min (WPM)</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stat-total-chars">0</span>
                        <span class="stat-label">Characters</span>
                    </div>
                </div>

                <div class="validation-section">
                    <div class="validation-header">
                        <h4>âš ï¸ Validation</h4>
                        <div class="validation-summary" id="validation-summary">
                            <span class="validation-badge success">âœ“ No issues</span>
                        </div>
                    </div>
                    <div class="validation-list" id="validation-list"></div>
                </div>

                <div class="stats-rules">
                    <h4>ðŸ“ Validation Rules</h4>
                    <ul>
                        <li><span class="rule-error">Error</span> Duration &lt; 0.5s or &gt; 25 chars/sec</li>
                        <li><span class="rule-warning">Warning</span> Duration &gt; 10s or line &gt; 42 chars</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- V3.0 - Marker Edit Modal -->
        <div id="marker-edit-modal" class="marker-edit-modal">
            <div class="marker-edit-content">
                <div class="modal-header">
                    <h2>ðŸ“ Edit Marker</h2>
                    <button class="modal-close" id="close-marker-modal">Ã—</button>
                </div>

                <div class="form-group">
                    <label>Marker label</label>
                    <input type="text" id="marker-label-input" placeholder="Ex: Refrain, Couplet 1, Intro..." />
                </div>

                <div class="form-group">
                    <label>Color</label>
                    <div class="marker-color-picker" id="marker-color-picker">
                        <div class="marker-color-option selected" data-color="#ff6b6b" style="background: #ff6b6b"></div>
                        <div class="marker-color-option" data-color="#feca57" style="background: #feca57"></div>
                        <div class="marker-color-option" data-color="#48dbfb" style="background: #48dbfb"></div>
                        <div class="marker-color-option" data-color="#1dd1a1" style="background: #1dd1a1"></div>
                        <div class="marker-color-option" data-color="#ff9ff3" style="background: #ff9ff3"></div>
                        <div class="marker-color-option" data-color="#54a0ff" style="background: #54a0ff"></div>
                        <div class="marker-color-option" data-color="#5f27cd" style="background: #5f27cd"></div>
                        <div class="marker-color-option" data-color="#ffffff" style="background: #ffffff"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Position: <span id="marker-time-display">0:00.000</span></label>
                </div>

                <div class="cue-actions">
                    <button id="save-marker-btn" class="btn btn-primary">ðŸ’¾ Save</button>
                    <button id="delete-marker-btn" class="btn btn-danger">ðŸ—‘ï¸ Delete</button>
                </div>
            </div>
        </div>

        <div class="container">
            <header class="top-bar">
                <div class="logo">
                    <h1>ðŸŽµ VTT Editor Pro V3.0</h1>
                    <span class="subtitle">Multi-Track â€¢ Markers â€¢ VTT/SRT/ASS/SBV/JSON Export</span>
                </div>

                <div class="controls-top">
                    <label class="toggle-container" title="Allow overlapping cues">
                        <input type="checkbox" id="allow-overlap" />
                        <span class="toggle-label">ðŸ”€ Allow Overlap</span>
                    </label>
                    <label class="toggle-container" title="Enable Snap-to-Grid">
                        <input type="checkbox" id="snap-enabled" />
                        <span class="toggle-label">ðŸ§² Snap Grid</span>
                    </label>
                    <!-- V3.0 - Custom Snap Dropdown -->
                    <div class="custom-dropdown" id="snap-dropdown">
                        <button class="custom-dropdown-btn" id="snap-dropdown-btn">
                            <span class="dropdown-icon">â±ï¸</span>
                            <span class="dropdown-label" id="snap-label">100ms</span>
                        </button>
                        <div class="custom-dropdown-menu" id="snap-dropdown-menu">
                            <div class="dropdown-option" data-value="0.01">
                                <span class="option-name">10ms</span>
                                <span class="option-desc">Ultra precise</span>
                            </div>
                            <div class="dropdown-option" data-value="0.05">
                                <span class="option-name">50ms</span>
                                <span class="option-desc">Very precise</span>
                            </div>
                            <div class="dropdown-option active" data-value="0.1">
                                <span class="option-name">100ms</span>
                                <span class="option-desc">Recommended</span>
                            </div>
                            <div class="dropdown-option" data-value="0.25">
                                <span class="option-name">250ms</span>
                                <span class="option-desc">Standard</span>
                            </div>
                            <div class="dropdown-option" data-value="0.5">
                                <span class="option-name">500ms</span>
                                <span class="option-desc">Half a second</span>
                            </div>
                            <div class="dropdown-option" data-value="1">
                                <span class="option-name">1s</span>
                                <span class="option-desc">Second</span>
                            </div>
                        </div>
                    </div>
                    <label for="audio-upload" class="btn btn-primary">
                        ðŸ“‚ Import MP3
                        <input type="file" id="audio-upload" accept="audio/*" style="display: none" />
                    </label>
                    <!-- V3.0 - Import Dropdown -->
                    <div class="import-dropdown" id="import-dropdown">
                        <button class="import-dropdown-btn" id="import-dropdown-btn">ðŸ“„ Import</button>
                        <div class="import-dropdown-menu">
                            <label for="vtt-upload">
                                <span class="import-format-icon">ðŸ“</span>
                                <span class="import-format-info">
                                    <span class="import-format-name">VTT</span>
                                    <span class="import-format-desc">WebVTT - Standard web</span>
                                </span>
                                <input type="file" id="vtt-upload" accept=".vtt" />
                            </label>
                            <label for="srt-upload">
                                <span class="import-format-icon">ðŸŽ¬</span>
                                <span class="import-format-info">
                                    <span class="import-format-name">SRT</span>
                                    <span class="import-format-desc">SubRip - Universal</span>
                                </span>
                                <input type="file" id="srt-upload" accept=".srt" />
                            </label>
                            <label for="ass-upload">
                                <span class="import-format-icon">ðŸŽ¨</span>
                                <span class="import-format-info">
                                    <span class="import-format-name">ASS</span>
                                    <span class="import-format-desc">Advanced SubStation Alpha</span>
                                </span>
                                <input type="file" id="ass-upload" accept=".ass,.ssa" />
                            </label>
                            <label for="sbv-upload">
                                <span class="import-format-icon">â–¶ï¸</span>
                                <span class="import-format-info">
                                    <span class="import-format-name">SBV</span>
                                    <span class="import-format-desc">YouTube Format</span>
                                </span>
                                <input type="file" id="sbv-upload" accept=".sbv" />
                            </label>
                            <label for="dfxp-upload">
                                <span class="import-format-icon">ðŸ“º</span>
                                <span class="import-format-info">
                                    <span class="import-format-name">DFXP</span>
                                    <span class="import-format-desc">TTML - Netflix/Broadcast</span>
                                </span>
                                <input type="file" id="dfxp-upload" accept=".dfxp,.ttml,.xml" />
                            </label>
                            <label for="json-upload">
                                <span class="import-format-icon">ðŸ“¦</span>
                                <span class="import-format-info">
                                    <span class="import-format-name">JSON</span>
                                    <span class="import-format-desc">Restore backup</span>
                                </span>
                                <input type="file" id="json-upload" accept=".json" />
                            </label>
                        </div>
                    </div>
                    <button id="play-btn" class="btn btn-play" disabled>â–¶ï¸ Play</button>
                    <button id="add-region-btn" class="btn btn-success" disabled>âž• Add Region</button>
                    <button id="batch-edit-btn" class="btn btn-warning" disabled>ðŸ“ Batch Edit</button>
                    <button id="manage-tracks-btn" class="btn btn-secondary" disabled>ðŸŽ¬ Tracks</button>
                    <!-- V3.0 - Export Dropdown -->
                    <div class="export-dropdown" id="export-dropdown">
                        <button class="export-dropdown-btn" id="export-dropdown-btn" disabled>ðŸ’¾ Export</button>
                        <div class="export-dropdown-menu">
                            <button id="export-vtt-btn">
                                <span class="export-format-icon">ðŸ“</span>
                                <span class="export-format-info">
                                    <span class="export-format-name">VTT</span>
                                    <span class="export-format-desc">WebVTT - Standard web</span>
                                </span>
                            </button>
                            <button id="export-srt-btn">
                                <span class="export-format-icon">ðŸŽ¬</span>
                                <span class="export-format-info">
                                    <span class="export-format-name">SRT</span>
                                    <span class="export-format-desc">SubRip - Universal</span>
                                </span>
                            </button>
                            <button id="export-ass-btn">
                                <span class="export-format-icon">ðŸŽ¨</span>
                                <span class="export-format-info">
                                    <span class="export-format-name">ASS</span>
                                    <span class="export-format-desc">Advanced SubStation Alpha</span>
                                </span>
                            </button>
                            <button id="export-sbv-btn">
                                <span class="export-format-icon">â–¶ï¸</span>
                                <span class="export-format-info">
                                    <span class="export-format-name">SBV</span>
                                    <span class="export-format-desc">YouTube Format</span>
                                </span>
                            </button>
                            <button id="export-dfxp-btn">
                                <span class="export-format-icon">ðŸ“º</span>
                                <span class="export-format-info">
                                    <span class="export-format-name">DFXP</span>
                                    <span class="export-format-desc">TTML - Netflix/Broadcast</span>
                                </span>
                            </button>
                            <button id="export-json-btn">
                                <span class="export-format-icon">ðŸ“¦</span>
                                <span class="export-format-info">
                                    <span class="export-format-name">JSON</span>
                                    <span class="export-format-desc">Full backup</span>
                                </span>
                            </button>
                        </div>
                    </div>
                    <!-- V3.0 - Theme Selector -->
                    <div class="theme-selector" id="theme-selector">
                        <button class="theme-btn" id="theme-btn">
                            <span id="theme-icon">ðŸŒ™</span>
                            <span id="theme-label">Dark</span>
                        </button>
                        <div class="theme-dropdown">
                            <div class="theme-option active" data-theme="dark">
                                <span class="theme-color dark"></span>
                                <span>ðŸŒ™ Dark</span>
                            </div>
                            <div class="theme-option" data-theme="light">
                                <span class="theme-color light"></span>
                                <span>â˜€ï¸ Light</span>
                            </div>
                            <div class="theme-option" data-theme="blue">
                                <span class="theme-color blue"></span>
                                <span>ðŸ’™ Blue</span>
                            </div>
                            <div class="theme-option" data-theme="purple">
                                <span class="theme-color purple"></span>
                                <span>ðŸ’œ Purple</span>
                            </div>
                            <div class="theme-option" data-theme="orange">
                                <span class="theme-color orange"></span>
                                <span>ðŸ§¡ Orange</span>
                            </div>
                        </div>
                    </div>
                </div>
            </header>

            <main class="editor-main">
                <div class="waveform-section">
                    <div class="waveform-header">
                        <h3>ðŸŽµ Timeline Audio - Drag regions to adjust</h3>
                        <div class="waveform-controls">
                            <button id="zoom-in" class="btn-icon" title="Zoom In">ðŸ”+</button>
                            <button id="zoom-out" class="btn-icon" title="Zoom Out">ðŸ”-</button>
                            <button id="add-marker-btn" class="btn-icon" title="Add Marker (M)" disabled>ðŸ“</button>
                            <button id="clear-markers-btn" class="btn-icon" title="Clear All Markers" disabled>ðŸ—‘ï¸ðŸ“</button>
                            <button id="undo-btn" class="btn-icon" title="Undo (Ctrl+Z)" disabled>â†¶</button>
                            <button id="redo-btn" class="btn-icon" title="Redo (Ctrl+Y)" disabled>â†·</button>
                            <!-- V3.0 - Go to time -->
                            <div class="goto-time-container">
                                <span class="goto-time-label">â±ï¸</span>
                                <input type="text" id="goto-time-input" class="goto-time-input" placeholder="0:00.000" title="Format: MM:SS.mmm ou SS.mmm" />
                                <button id="goto-time-btn" class="goto-time-btn">Go</button>
                            </div>
                            <span id="current-time">00:00.000</span> / <span id="total-duration">00:00.000</span>
                        </div>
                    </div>

                    <div class="waveform-info">
                        <p>ðŸ’¡ <strong>Double-click</strong> on region to edit â€¢ <strong>Drag edges</strong> to adjust â€¢ <strong>Drag center</strong> to move â€¢ <strong>Auto-save</strong> every 5s</p>
                    </div>

                    <div id="waveform"></div>

                    <!-- V3.0 - Minimap -->
                    <div class="minimap-container" id="minimap-container">
                        <div class="minimap-header">
                            <h4>ðŸ—ºï¸ Global View</h4>
                            <button class="minimap-toggle" id="minimap-toggle">Hide</button>
                        </div>
                        <div class="minimap" id="minimap">
                            <div class="minimap-playhead" id="minimap-playhead"></div>
                            <div class="minimap-viewport" id="minimap-viewport"></div>
                        </div>
                    </div>
                </div>

                <div class="editor-section">
                    <div class="cue-editor">
                        <h3>âœï¸ Edit Cue</h3>

                        <!-- V3.0 - Custom Track Dropdown -->
                        <div class="track-selector-row">
                            <label>ðŸŽ¬ Track:</label>
                            <div class="custom-dropdown" id="track-dropdown">
                                <button class="custom-dropdown-btn" id="track-dropdown-btn">
                                    <span class="dropdown-icon">ðŸŽµ</span>
                                    <span class="dropdown-label" id="track-label">Main Track</span>
                                </button>
                                <div class="custom-dropdown-menu" id="track-dropdown-menu">
                                    <div class="dropdown-option active" data-value="default">
                                        <span class="option-name">Main Track</span>
                                        <span class="option-desc">Main track</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="cue-form">
                            <div class="form-row">
                                <div class="form-group">
                                    <label>â±ï¸ Start (s)</label>
                                    <input type="number" id="cue-start" step="0.001" placeholder="0.000" min="0" />
                                </div>

                                <div class="form-group">
                                    <label>â±ï¸ End (s)</label>
                                    <input type="number" id="cue-end" step="0.001" placeholder="0.000" min="0" />
                                </div>

                                <div class="form-group mark-buttons">
                                    <button id="mark-start" class="btn btn-secondary" title="Mark start">â®ï¸ Start</button>
                                    <button id="mark-end" class="btn btn-secondary" title="Mark end">â­ï¸ End</button>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>ðŸ“ Text</label>
                                <textarea id="cue-text" placeholder="Type the lyrics here..." rows="3"></textarea>
                            </div>

                            <div class="form-group">
                                <label>ðŸŽ¨ Region Color</label>
                                <div class="color-picker">
                                    <input type="color" id="region-color" value="#1db954" />
                                    <button id="random-color" class="btn-icon" title="Random color">ðŸŽ²</button>
                                </div>
                            </div>

                            <div class="cue-actions">
                                <button id="add-cue" class="btn btn-primary">âž• Add Cue</button>
                                <button id="update-cue" class="btn btn-warning" style="display: none">ðŸ’¾ Update</button>
                                <button id="delete-current" class="btn btn-danger" style="display: none">ðŸ—‘ï¸ Delete</button>
                                <button id="cancel-edit" class="btn btn-secondary" style="display: none">âŒ Cancel</button>
                            </div>

                            <!-- V3.0 - Advanced Editing Tools -->
                            <div class="advanced-edit-section">
                                <h4>âœ‚ï¸ Advanced Editing</h4>
                                <div class="advanced-edit-buttons">
                                    <button id="split-cue-btn" class="btn-edit-tool split" disabled title="Divide the selected cue at the cursor position">âœ‚ï¸ Split</button>
                                    <button id="merge-cues-btn" class="btn-edit-tool merge" disabled title="Merge 2 consecutive selected cues into one">ðŸ”— Merge</button>
                                    <button id="shift-timings-btn" class="btn-edit-tool shift" disabled title="Shift all timings by Â±X seconds">â±ï¸ Shift All</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="cues-list-section">
                        <div class="cues-header">
                            <h3>ðŸ“‹ List of Cues (<span id="cues-count">0</span>)</h3>
                            <div class="cues-header-actions">
                                <button id="stats-btn" class="btn btn-stats">ðŸ“Š Stats</button>
                                <button id="clear-all" class="btn btn-danger" disabled>ðŸ—‘ï¸ Clear All</button>
                            </div>
                        </div>

                        <!-- V3.0 - Search Box -->
                        <div class="search-box">
                            <div class="search-wrapper">
                                <span class="search-icon">ðŸ”</span>
                                <input type="text" id="cue-search" class="search-input" placeholder="Search in cues..." />
                                <button id="search-clear" class="search-clear" title="Clear">Ã—</button>
                            </div>
                        </div>
                        <div id="search-results-count" class="search-results-count"></div>

                        <div id="cues-list" class="cues-list">
                            <div class="no-cues">
                                <p>ðŸŽµ No cue. Import an MP3 and add regions!</p>
                            </div>
                        </div>
                    </div>

                    <div class="lyrics-section">
                        <div class="lyrics-header">
                            <h3>ðŸ“ Complete lyrics</h3>
                        </div>

                        <div id="lyrics-content" class="lyrics-content">
                            <div style="color: #666; text-align: center; margin-top: 50px; font-style: italic">
                                <p>ðŸŽ¤ The lyrics will appear here</p>
                            </div>
                        </div>
                    </div>
                </div>
            </main>

            <footer class="shortcuts-bar">
                <div class="shortcut"><kbd>Space</kbd> Play/Pause</div>
                <div class="shortcut"><kbd>â†</kbd> -1s</div>
                <div class="shortcut"><kbd>â†’</kbd> +1s</div>
                <div class="shortcut"><kbd>Ctrl+S</kbd> Mark Start</div>
                <div class="shortcut"><kbd>Ctrl+B</kbd> Mark End</div>
                <div class="shortcut"><kbd>Ctrl+Enter</kbd> Add Cue</div>
                <div class="shortcut"><kbd>Ctrl+Z</kbd> Undo</div>
                <div class="shortcut"><kbd>Ctrl+Y</kbd> Redo</div>
                <div class="shortcut"><kbd>Delete</kbd> Delete Region</div>
                <div class="shortcut"><kbd>M</kbd> Add Marker</div>
                <div class="shortcut" style="color: #1db954">ðŸ’¡ Multi-track â€¢ Markers â€¢ Multi-format Export</div>
            </footer>
        </div>

        <script>
            let wavesurfer = null;
            let regionsPlugin = null;
            let cues = [];
            let currentCueId = null;
            let isPlaying = false;
            let audioFile = null;
            let activeRegion = null;
            let currentZoom = 50;
            let allowOverlap = false;

            let history = [];
            let historyIndex = -1;
            const MAX_HISTORY = 20;

            let autoSaveInterval = null;
            let activeLyricId = null;

            const GAP_MINIMUM = 0.0001; // 0.1ms

            // V2.1 - New variables
            let snapEnabled = false;
            let snapInterval = 0.1;
            let resizeTooltip = null;
            let isResizing = false;
            let currentResizingRegion = null;
            let resizeInitialStart = 0;
            let resizeInitialEnd = 0;
            let mouseX = 0;
            let mouseY = 0;

            // V2.2 - New variables
            let markers = [];
            let tracks = [{ id: "default", name: "Main Track", cues: [], color: "#1db954" }];
            let currentTrackId = "default";
            let markerIdCounter = 0;

            const elements = {
                audioUpload: document.getElementById("audio-upload"),
                vttUpload: document.getElementById("vtt-upload"),
                srtUpload: document.getElementById("srt-upload"),
                // V3.0 - Import dropdown
                assUpload: document.getElementById("ass-upload"),
                sbvUpload: document.getElementById("sbv-upload"),
                dfxpUpload: document.getElementById("dfxp-upload"),
                jsonUpload: document.getElementById("json-upload"),
                importDropdown: document.getElementById("import-dropdown"),
                importDropdownBtn: document.getElementById("import-dropdown-btn"),
                playBtn: document.getElementById("play-btn"),
                // V3.0 - Export dropdown
                exportDropdown: document.getElementById("export-dropdown"),
                exportDropdownBtn: document.getElementById("export-dropdown-btn"),
                exportVttBtn: document.getElementById("export-vtt-btn"),
                addRegionBtn: document.getElementById("add-region-btn"),
                zoomIn: document.getElementById("zoom-in"),
                zoomOut: document.getElementById("zoom-out"),
                undoBtn: document.getElementById("undo-btn"),
                redoBtn: document.getElementById("redo-btn"),
                currentTime: document.getElementById("current-time"),
                totalDuration: document.getElementById("total-duration"),
                cueStart: document.getElementById("cue-start"),
                cueEnd: document.getElementById("cue-end"),
                cueText: document.getElementById("cue-text"),
                regionColor: document.getElementById("region-color"),
                randomColor: document.getElementById("random-color"),
                markStart: document.getElementById("mark-start"),
                markEnd: document.getElementById("mark-end"),
                addCue: document.getElementById("add-cue"),
                updateCue: document.getElementById("update-cue"),
                deleteCurrent: document.getElementById("delete-current"),
                cancelEdit: document.getElementById("cancel-edit"),
                cuesList: document.getElementById("cues-list"),
                cuesCount: document.getElementById("cues-count"),
                clearAll: document.getElementById("clear-all"),
                toastContainer: document.getElementById("toast-container"),
                lyricsContent: document.getElementById("lyrics-content"),
                allowOverlap: document.getElementById("allow-overlap"),
                // V2.1 - New elements
                snapEnabled: document.getElementById("snap-enabled"),
                // snapInterval: removed - now using custom dropdown
                batchEditBtn: document.getElementById("batch-edit-btn"),
                batchModal: document.getElementById("batch-modal"),
                closeBatchModal: document.getElementById("close-batch-modal"),
                batchTotalCues: document.getElementById("batch-total-cues"),
                batchRange: document.getElementById("batch-range"),
                findText: document.getElementById("find-text"),
                replaceText: document.getElementById("replace-text"),
                caseSensitive: document.getElementById("case-sensitive"),
                applyReplace: document.getElementById("apply-replace"),
                transformUppercase: document.getElementById("transform-uppercase"),
                transformLowercase: document.getElementById("transform-lowercase"),
                transformCapitalize: document.getElementById("transform-capitalize"),
                transformSentence: document.getElementById("transform-sentence"),
                prefixText: document.getElementById("prefix-text"),
                suffixText: document.getElementById("suffix-text"),
                cueRange: document.getElementById("cue-range"),
                applyPrefix: document.getElementById("apply-prefix"),
                applySuffix: document.getElementById("apply-suffix"),
                applyBoth: document.getElementById("apply-both"),
                // V2.2 - New elements
                addMarkerBtn: document.getElementById("add-marker-btn"),
                clearMarkersBtn: document.getElementById("clear-markers-btn"),
                manageTracksBtn: document.getElementById("manage-tracks-btn"),
                // V3.0 - Export buttons
                exportSrtBtn: document.getElementById("export-srt-btn"),
                exportAssBtn: document.getElementById("export-ass-btn"),
                exportSbvBtn: document.getElementById("export-sbv-btn"),
                exportDfxpBtn: document.getElementById("export-dfxp-btn"),
                exportJsonBtn: document.getElementById("export-json-btn"),
                // trackSelect: removed - now using custom dropdown
                trackModal: document.getElementById("track-modal"),
                closeTrackModal: document.getElementById("close-track-modal"),
                newTrackName: document.getElementById("new-track-name"),
                createTrackBtn: document.getElementById("create-track-btn"),
                trackList: document.getElementById("track-list"),
                // V3.0 - Advanced editing tools
                splitCueBtn: document.getElementById("split-cue-btn"),
                mergeCuesBtn: document.getElementById("merge-cues-btn"),
                shiftTimingsBtn: document.getElementById("shift-timings-btn"),
                // V3.0 - Shift modal
                shiftModal: document.getElementById("shift-modal"),
                closeShiftModal: document.getElementById("close-shift-modal"),
                shiftValue: document.getElementById("shift-value"),
                shiftPreviewValue: document.getElementById("shift-preview-value"),
                shiftCuesCount: document.getElementById("shift-cues-count"),
                shiftMinus1: document.getElementById("shift-minus-1"),
                shiftMinus01: document.getElementById("shift-minus-01"),
                shiftPlus01: document.getElementById("shift-plus-01"),
                shiftPlus1: document.getElementById("shift-plus-1"),
                applyShiftBtn: document.getElementById("apply-shift-btn"),
                cancelShiftBtn: document.getElementById("cancel-shift-btn"),
                // V3.0 - Search & Navigation
                cueSearch: document.getElementById("cue-search"),
                searchClear: document.getElementById("search-clear"),
                searchResultsCount: document.getElementById("search-results-count"),
                gotoTimeInput: document.getElementById("goto-time-input"),
                gotoTimeBtn: document.getElementById("goto-time-btn"),
            };

            function showToast(message, type = "info") {
                const icons = {
                    success: "âœ…",
                    error: "âŒ",
                    warning: "âš ï¸",
                    info: "â„¹ï¸",
                };

                const toast = document.createElement("div");
                toast.className = `toast ${type}`;
                toast.innerHTML = `
                    <span class="toast-icon">${icons[type]}</span>
                    <span class="toast-content">${message}</span>
                    <button class="toast-close">Ã—</button>
                `;

                elements.toastContainer.appendChild(toast);

                toast.querySelector(".toast-close").addEventListener("click", () => {
                    toast.remove();
                });

                setTimeout(() => {
                    toast.remove();
                }, 5000);
            }

            function generateRandomColor() {
                const colors = ["#1db954", "#ff6b6b", "#4ecdc4", "#45b7d1", "#f9ca24", "#ff9ff3", "#54a0ff", "#48dbfb", "#ff6348", "#1dd1a1", "#feca57", "#ee5a6f", "#c44569", "#3867d6", "#8854d0", "#20bf6b"];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            function saveToHistory() {
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }

                history.push(JSON.parse(JSON.stringify(cues)));

                if (history.length > MAX_HISTORY) {
                    history.shift();
                } else {
                    historyIndex++;
                }

                updateUndoRedoButtons();
            }

            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    cues = JSON.parse(JSON.stringify(history[historyIndex]));
                    rebuildRegions();
                    renderCues();
                    renderLyrics();
                    clearForm();
                    updateUndoRedoButtons();
                    showToast("Action canceled", "info");
                }
            }

            function redo() {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    cues = JSON.parse(JSON.stringify(history[historyIndex]));
                    rebuildRegions();
                    renderCues();
                    renderLyrics();
                    clearForm();
                    updateUndoRedoButtons();
                    showToast("Action restored", "info");
                }
            }

            function updateUndoRedoButtons() {
                elements.undoBtn.disabled = historyIndex <= 0;
                elements.redoBtn.disabled = historyIndex >= history.length - 1;
            }

            function rebuildRegions() {
                clearAllRegions();
                cues.forEach((cue) => {
                    // Ensure cue has a color
                    if (!cue.color) {
                        cue.color = generateRandomColor();
                    }
                    createRegion(cue.start, cue.end, cue.color, cue.id);
                });
            }

            function renderLyrics() {
                if (cues.length === 0) {
                    elements.lyricsContent.innerHTML = `
                        <div style="color: #666; text-align: center; margin-top: 50px; font-style: italic;">
                            <p>ðŸŽ¤ The lyrics will appear here</p>
                        </div>
                    `;
                    return;
                }

                elements.lyricsContent.innerHTML = "";

                cues.forEach((cue, index) => {
                    const lyricLine = document.createElement("div");
                    lyricLine.className = "lyric-line";
                    lyricLine.dataset.cueId = cue.id;
                    lyricLine.dataset.start = cue.start;
                    lyricLine.dataset.end = cue.end;

                    lyricLine.innerHTML = `
                        <div class="lyric-time">${formatTimeVTT(cue.start)} - ${formatTimeVTT(cue.end)}</div>
                        <div class="lyric-text">${cue.text || '<i style="color:#666;">No text</i>'}</div>
                    `;

                    lyricLine.addEventListener("click", () => {
                        playCue(cue.id);
                    });

                    elements.lyricsContent.appendChild(lyricLine);
                });
            }

            function updateActiveLyric() {
                if (!wavesurfer || cues.length === 0) return;

                const currentTime = wavesurfer.getCurrentTime();
                const lyricLines = elements.lyricsContent.querySelectorAll(".lyric-line");

                let newActiveLyricId = null;

                lyricLines.forEach((line) => {
                    const start = parseFloat(line.dataset.start);
                    const end = parseFloat(line.dataset.end);
                    const cueId = line.dataset.cueId;

                    if (currentTime >= start && currentTime <= end) {
                        line.classList.add("active");
                        newActiveLyricId = cueId;

                        // V3.0 - Scroll within container only, not the whole page
                        if (activeLyricId !== cueId) {
                            const container = document.getElementById("lyrics-content");
                            if (container) {
                                const containerRect = container.getBoundingClientRect();
                                const lineRect = line.getBoundingClientRect();
                                const scrollTop = container.scrollTop + (lineRect.top - containerRect.top) - containerRect.height / 2 + lineRect.height / 2;
                                container.scrollTo({ top: scrollTop, behavior: "smooth" });
                            }
                        }
                    } else {
                        line.classList.remove("active");
                    }
                });

                activeLyricId = newActiveLyricId;
            }

            function checkOverlap(start, end, excludeId = null) {
                if (allowOverlap) return null;

                for (let cue of cues) {
                    if (excludeId && cue.id === excludeId) continue;

                    if (start < cue.end && end > cue.start) {
                        return cue;
                    }
                }
                return null;
            }

            function getAdjacentCues(cueId) {
                const index = cues.findIndex((c) => c.id === cueId);
                if (index === -1) return { prev: null, next: null };

                return {
                    prev: index > 0 ? cues[index - 1] : null,
                    next: index < cues.length - 1 ? cues[index + 1] : null,
                };
            }

            function snapRegionToNeighbors(region) {
                if (allowOverlap) return;

                const cue = cues.find((c) => c.id === region.id);
                if (!cue) return;

                const { prev, next } = getAdjacentCues(cue.id);

                let needsUpdate = false;
                let newStart = region.start;
                let newEnd = region.end;

                if (prev && newStart < prev.end) {
                    newStart = prev.end + GAP_MINIMUM;
                    needsUpdate = true;
                }

                if (next && newEnd > next.start) {
                    newEnd = next.start - GAP_MINIMUM;
                    needsUpdate = true;
                }

                if (newStart >= newEnd) {
                    newStart = region.start;
                    newEnd = region.end;
                    needsUpdate = false;
                }

                if (needsUpdate) {
                    region.setOptions({
                        start: newStart,
                        end: newEnd,
                    });
                    cue.start = newStart;
                    cue.end = newEnd;
                    renderCues();
                    renderLyrics();
                }
            }

            function saveToLocalStorage() {
                try {
                    // V2.2 - Save current track's cues before saving
                    const currentTrack = getCurrentTrack();
                    if (currentTrack) {
                        currentTrack.cues = JSON.parse(JSON.stringify(cues));
                    }

                    const data = {
                        cues: cues,
                        audioFileName: audioFile ? audioFile.name : null,
                        timestamp: Date.now(),
                        // V2.2 - Save markers and tracks
                        markers: markers,
                        tracks: tracks,
                        currentTrackId: currentTrackId,
                    };
                    localStorage.setItem("vtt-editor-data", JSON.stringify(data));
                } catch (e) {
                    console.error("LocalStorage save failed:", e);
                }
            }

            function loadFromLocalStorage() {
                try {
                    const data = localStorage.getItem("vtt-editor-data");
                    if (data) {
                        const parsed = JSON.parse(data);

                        // Count the items to be loaded
                        const cuesCount = (parsed.cues && parsed.cues.length) || 0;
                        const markersCount = (parsed.markers && parsed.markers.length) || 0;
                        const tracksCount = (parsed.tracks && parsed.tracks.length) || 0;

                        if (cuesCount > 0 || markersCount > 0 || tracksCount > 0) {
                            let message = `ðŸ’¾ Saved data found:\n`;
                            if (cuesCount > 0) message += `- ${cuesCount} cues\n`;
                            if (markersCount > 0) message += `- ${markersCount} markers\n`;
                            if (tracksCount > 0) message += `- ${tracksCount} tracks\n`;
                            message += `\nLoad?`;
                            const confirmLoad = confirm(message);
                            if (confirmLoad) {
                                // V2.2 - Load tracks first
                                if (parsed.tracks && parsed.tracks.length > 0) {
                                    tracks = parsed.tracks;
                                    currentTrackId = parsed.currentTrackId || "default";
                                    renderTrackSelector();
                                }

                                // Load cues
                                if (parsed.cues) {
                                    cues = parsed.cues;
                                    rebuildRegions();
                                    renderCues();
                                    renderLyrics();
                                    saveToHistory();
                                }

                                // V2.2 - Load markers
                                if (parsed.markers && parsed.markers.length > 0) {
                                    markers = parsed.markers;
                                    markerIdCounter = Math.max(...markers.map((m) => parseInt(m.id.split("-")[1]) || 0)) + 1;
                                    renderAllMarkers();
                                    updateMarkerButtons();
                                }

                                showToast("Data restored from LocalStorage", "success");
                            }
                        }
                    }
                } catch (e) {
                    console.error("LocalStorage load failed:", e);
                }
            }

            function startAutoSave() {
                if (autoSaveInterval) {
                    clearInterval(autoSaveInterval);
                }
                autoSaveInterval = setInterval(() => {
                    // V2.2 - Save even if no cues (markers and tracks may exist)
                    if (cues.length > 0 || markers.length > 0 || tracks.length > 1) {
                        saveToLocalStorage();
                    }
                }, 5000);
            }

            function detectOverlaps() {
                if (allowOverlap) return [];

                const overlaps = [];
                for (let i = 0; i < cues.length; i++) {
                    for (let j = i + 1; j < cues.length; j++) {
                        const a = cues[i];
                        const b = cues[j];
                        if (a.start < b.end && a.end > b.start) {
                            if (!overlaps.includes(a.id)) overlaps.push(a.id);
                            if (!overlaps.includes(b.id)) overlaps.push(b.id);
                        }
                    }
                }
                return overlaps;
            }

            function parseVTT(content) {
                const lines = content.split("\n");
                const parsedCues = [];
                let i = 0;

                while (i < lines.length) {
                    const line = lines[i].trim();

                    if (line.includes("-->")) {
                        // Check previous line for color info
                        let color = generateRandomColor();
                        if (i > 0) {
                            const prevLine = lines[i - 1].trim();
                            const colorMatch = prevLine.match(/\[color:\s*(#[0-9A-Fa-f]{6})\]/);
                            if (colorMatch) {
                                color = colorMatch[1];
                            }
                        }

                        const timeParts = line.split("-->");
                        const start = parseVTTTime(timeParts[0].trim());
                        const end = parseVTTTime(timeParts[1].trim());

                        i++;
                        let text = "";
                        while (i < lines.length && lines[i].trim() !== "") {
                            text += lines[i].trim() + " ";
                            i++;
                        }

                        if (start !== null && end !== null) {
                            parsedCues.push({
                                id: generateCueId(),
                                start: start,
                                end: end,
                                text: text.trim(),
                                color: color,
                            });
                        }
                    }
                    i++;
                }

                return parsedCues;
            }

            function parseVTTTime(timeStr) {
                const parts = timeStr.split(":");
                if (parts.length === 3) {
                    const hours = parseInt(parts[0]);
                    const minutes = parseInt(parts[1]);
                    const seconds = parseFloat(parts[2]);
                    return hours * 3600 + minutes * 60 + seconds;
                } else if (parts.length === 2) {
                    const minutes = parseInt(parts[0]);
                    const seconds = parseFloat(parts[1]);
                    return minutes * 60 + seconds;
                }
                return null;
            }

            // V2.2 - Parse SRT format
            function parseSRT(content) {
                const lines = content.split("\n");
                const parsedCues = [];
                let i = 0;

                while (i < lines.length) {
                    const line = lines[i].trim();

                    // SRT format: line with -->
                    if (line.includes("-->")) {
                        const timeParts = line.split("-->");
                        const start = parseSRTTime(timeParts[0].trim());
                        const end = parseSRTTime(timeParts[1].trim());

                        i++;
                        let text = "";
                        // Read all text lines until empty line
                        while (i < lines.length && lines[i].trim() !== "") {
                            text += lines[i].trim() + " ";
                            i++;
                        }

                        if (start !== null && end !== null) {
                            parsedCues.push({
                                id: generateCueId(),
                                start: start,
                                end: end,
                                text: text.trim(),
                                color: generateRandomColor(),
                            });
                        }
                    }
                    i++;
                }

                return parsedCues;
            }

            function parseSRTTime(timeStr) {
                // SRT format uses comma for milliseconds: 00:00:01,500
                // Replace comma with dot to make it parseable
                timeStr = timeStr.replace(",", ".");

                const parts = timeStr.split(":");
                if (parts.length === 3) {
                    const hours = parseInt(parts[0]);
                    const minutes = parseInt(parts[1]);
                    const seconds = parseFloat(parts[2]);
                    return hours * 3600 + minutes * 60 + seconds;
                } else if (parts.length === 2) {
                    const minutes = parseInt(parts[0]);
                    const seconds = parseFloat(parts[1]);
                    return minutes * 60 + seconds;
                }
                return null;
            }

            function initWaveSurfer() {
                regionsPlugin = WaveSurfer.Regions.create();

                wavesurfer = WaveSurfer.create({
                    container: "#waveform",
                    waveColor: "#404040",
                    progressColor: "#1db954",
                    cursorColor: "#1ed760",
                    barWidth: 2,
                    barRadius: 3,
                    cursorWidth: 2,
                    height: 180,
                    barGap: 2,
                    normalize: true,
                    backend: "WebAudio",
                    plugins: [regionsPlugin],
                });

                wavesurfer.on("ready", () => {
                    const duration = wavesurfer.getDuration();
                    elements.totalDuration.textContent = formatTime(duration);
                    elements.playBtn.disabled = false;
                    elements.exportDropdownBtn.disabled = false;
                    elements.clearAll.disabled = false;
                    elements.addRegionBtn.disabled = false;
                    // V3.0 - Enable additional buttons
                    elements.batchEditBtn.disabled = false;
                    elements.manageTracksBtn.disabled = false;
                    elements.addMarkerBtn.disabled = false;

                    loadFromLocalStorage();
                    startAutoSave();
                    updateAdvancedEditButtons(); // V3.0
                    updateMinimap(); // V3.0
                    renderAllMarkers(); // V3.0
                });

                wavesurfer.on("audioprocess", () => {
                    updateCurrentTime();
                    updateMinimapPlayhead(); // V3.0
                });

                wavesurfer.on("seek", () => {
                    updateCurrentTime();
                    updateMinimapPlayhead(); // V3.0
                });

                // V2.2 - Update time on click/interaction
                wavesurfer.on("interaction", () => {
                    updateCurrentTime();
                    updateMinimapPlayhead(); // V3.0
                });

                wavesurfer.on("finish", () => {
                    isPlaying = false;
                    elements.playBtn.textContent = "â–¶ï¸ Play";
                });

                regionsPlugin.on("region-created", (region) => {
                    setupRegionEvents(region);
                });

                regionsPlugin.on("region-updated", (region) => {
                    updateCueFromRegion(region);
                });

                regionsPlugin.on("region-clicked", (region, e) => {
                    e.stopPropagation();
                    activeRegion = region;
                    selectCueByRegion(region);
                });

                regionsPlugin.on("region-double-clicked", (region, e) => {
                    e.stopPropagation();
                    activeRegion = region;
                    editCueByRegion(region);
                });
            }

            function setupRegionEvents(region) {
                // V2.2 - Enhanced resize tooltip with mousedown/mouseup
                let updateTimeout = null;
                let isMouseDown = false;

                // Event mousedown on the region element
                region.element.addEventListener("mousedown", (e) => {
                    isMouseDown = true;
                    isResizing = true;
                    currentResizingRegion = region;
                    resizeInitialStart = region.start;
                    resizeInitialEnd = region.end;

                    // Display tooltip immediately on click
                    if (mouseX && mouseY) {
                        showResizeTooltipDual(mouseX, mouseY, region.start, region.end, false);
                    }
                });

                // Global mouseup event
                const handleMouseUp = () => {
                    if (isMouseDown && currentResizingRegion === region) {
                        isMouseDown = false;

                        // Apply snap-to-grid
                        if (snapEnabled) {
                            const snappedStart = snapToGrid(region.start);
                            const snappedEnd = snapToGrid(region.end);

                            if (snappedStart < snappedEnd) {
                                region.setOptions({
                                    start: snappedStart,
                                    end: snappedEnd,
                                });
                            }
                        }

                        snapRegionToNeighbors(region);
                        updateCueFromRegion(region);
                        saveToHistory();

                        // Hide tooltip and reset
                        isResizing = false;
                        currentResizingRegion = null;
                        resizeInitialStart = 0;
                        resizeInitialEnd = 0;
                        hideResizeTooltip();
                    }
                };

                document.addEventListener("mouseup", handleMouseUp);

                // Event update for updating during drag/resize
                region.on("update", () => {
                    if (isMouseDown && mouseX && mouseY) {
                        // Detect the type of action
                        const startChanged = Math.abs(region.start - resizeInitialStart) > 0.001;
                        const endChanged = Math.abs(region.end - resizeInitialEnd) > 0.001;
                        const isDragging = startChanged && endChanged;

                        if (region.updatingSide === "start") {
                            // Handle START moved
                            showResizeTooltipDual(mouseX, mouseY, region.start, null, false);
                        } else if (region.updatingSide === "end") {
                            // Handle END moved
                            showResizeTooltipDual(mouseX, mouseY, null, region.end, false);
                        } else if (isDragging) {
                            // DRAG of the entire region - display both timestamps
                            showResizeTooltipDual(mouseX, mouseY, region.start, region.end, true);
                        } else {
                            // Fallback
                            showResizeTooltipDual(mouseX, mouseY, region.start, region.end, false);
                        }
                    }
                });
            }

            function createRegion(start, end, color, id) {
                const region = regionsPlugin.addRegion({
                    start: start,
                    end: end,
                    color: color + "40",
                    drag: true,
                    resize: true,
                    id: id,
                });

                // V2.2 - Attach events to existing regions
                setupRegionEvents(region);

                return region;
            }

            function updateRegion(id, start, end, color) {
                const regions = regionsPlugin.getRegions();
                const region = regions.find((r) => r.id === id);
                if (region) {
                    region.setOptions({
                        start: start,
                        end: end,
                        color: color + "40",
                    });
                }
            }

            function deleteRegion(id) {
                const regions = regionsPlugin.getRegions();
                const region = regions.find((r) => r.id === id);
                if (region) {
                    region.remove();
                }
            }

            function clearAllRegions() {
                regionsPlugin.clearRegions();
            }

            function updateCueFromRegion(region) {
                const cue = cues.find((c) => c.id === region.id);
                if (cue) {
                    cue.start = region.start;
                    cue.end = region.end;

                    if (currentCueId === cue.id) {
                        elements.cueStart.value = cue.start.toFixed(3);
                        elements.cueEnd.value = cue.end.toFixed(3);
                    }

                    renderCues();
                    renderLyrics();
                }
            }

            function selectCueByRegion(region) {
                const cue = cues.find((c) => c.id === region.id);
                if (cue) {
                    currentCueId = cue.id;
                    elements.cueStart.value = cue.start.toFixed(3);
                    elements.cueEnd.value = cue.end.toFixed(3);
                    elements.cueText.value = cue.text;
                    elements.regionColor.value = cue.color;

                    elements.addCue.style.display = "none";
                    elements.updateCue.style.display = "block";
                    elements.deleteCurrent.style.display = "block";
                    elements.cancelEdit.style.display = "block";

                    updateActiveClass();
                }
            }

            function editCueByRegion(region) {
                selectCueByRegion(region);
                elements.cueText.focus();
            }

            function updateCurrentTime() {
                const time = wavesurfer.getCurrentTime();
                elements.currentTime.textContent = formatTime(time);
                updateActiveLyric();
            }

            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = (seconds % 60).toFixed(3);
                return `${mins.toString().padStart(2, "0")}:${secs.padStart(6, "0")}`;
            }

            function formatTimeVTT(seconds) {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = (seconds % 60).toFixed(3);
                return `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}:${secs.padStart(6, "0")}`;
            }

            function generateCueId() {
                return `cue-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            }

            function addQuickRegion() {
                if (!wavesurfer) return;

                const currentTime = wavesurfer.getCurrentTime();
                const duration = wavesurfer.getDuration();
                const start = Math.min(currentTime, duration - 2);
                const end = Math.min(start + 2, duration);

                const id = generateCueId();
                const color = generateRandomColor();

                const cue = {
                    id: id,
                    start: start,
                    end: end,
                    text: "",
                    color: color,
                };

                cues.push(cue);
                createRegion(start, end, color, id);
                sortCues();
                renderCues();
                renderLyrics();
                saveToHistory();

                currentCueId = id;
                elements.cueStart.value = start.toFixed(3);
                elements.cueEnd.value = end.toFixed(3);
                elements.cueText.value = "";
                elements.regionColor.value = color;

                elements.addCue.style.display = "none";
                elements.updateCue.style.display = "block";
                elements.deleteCurrent.style.display = "block";
                elements.cancelEdit.style.display = "block";

                elements.cueText.focus();
                updateActiveClass();
            }

            function addCue() {
                const start = parseFloat(elements.cueStart.value);
                const end = parseFloat(elements.cueEnd.value);
                const text = elements.cueText.value.trim();
                const color = elements.regionColor.value;

                if (isNaN(start) || isNaN(end)) {
                    showToast("Please enter valid timings!", "error");
                    return;
                }

                if (start >= end) {
                    showToast("Start must be before end!", "error");
                    return;
                }

                if (!text) {
                    showToast("Please enter some text!", "warning");
                    return;
                }

                const overlappingCue = checkOverlap(start, end);
                if (overlappingCue) {
                    showToast(`âŒ Overlap with cue "${overlappingCue.text.substring(0, 30)}..." - ${allowOverlap ? "Allowed" : "Blocked"}`, "error");
                    if (!allowOverlap) return;
                }

                const id = generateCueId();
                const cue = {
                    id: id,
                    start: start,
                    end: end,
                    text: text,
                    color: color,
                };

                cues.push(cue);
                createRegion(start, end, color, id);
                sortCues();
                renderCues();
                renderLyrics();
                clearForm();
                saveToHistory();
                showToast("Cue added!", "success");
            }

            function updateCue() {
                if (!currentCueId) return;

                const start = parseFloat(elements.cueStart.value);
                const end = parseFloat(elements.cueEnd.value);
                const text = elements.cueText.value.trim();
                const color = elements.regionColor.value;

                if (isNaN(start) || isNaN(end)) {
                    showToast("Please enter valid timings!", "error");
                    return;
                }

                if (start >= end) {
                    showToast("Start must be before end!", "error");
                    return;
                }

                if (!text) {
                    showToast("Please enter some text!", "warning");
                    return;
                }

                const overlappingCue = checkOverlap(start, end, currentCueId);
                if (overlappingCue) {
                    showToast(`âŒ Overlap with cue "${overlappingCue.text.substring(0, 30)}..." - ${allowOverlap ? "Allowed" : "Blocked"}`, "error");
                    if (!allowOverlap) return;
                }

                const cue = cues.find((c) => c.id === currentCueId);
                if (cue) {
                    cue.start = start;
                    cue.end = end;
                    cue.text = text;
                    cue.color = color;

                    updateRegion(currentCueId, start, end, color);
                    sortCues();
                    renderCues();
                    renderLyrics();
                    clearForm();
                    saveToHistory();
                    showToast("Cue updated!", "success");
                }
            }

            function deleteCue(id) {
                cues = cues.filter((c) => c.id !== id);
                deleteRegion(id);
                renderCues();
                renderLyrics();
                saveToHistory();
                if (currentCueId === id) {
                    clearForm();
                }
            }

            function deleteCurrentCue() {
                if (!currentCueId) return;
                deleteCue(currentCueId);
                showToast("Cue deleted", "info");
            }

            function editCue(id) {
                const cue = cues.find((c) => c.id === id);
                if (!cue) return;

                currentCueId = id;
                activeRegion = regionsPlugin.getRegions().find((r) => r.id === id);

                elements.cueStart.value = cue.start.toFixed(3);
                elements.cueEnd.value = cue.end.toFixed(3);
                elements.cueText.value = cue.text;
                elements.regionColor.value = cue.color;

                elements.addCue.style.display = "none";
                elements.updateCue.style.display = "block";
                elements.deleteCurrent.style.display = "block";
                elements.cancelEdit.style.display = "block";

                updateActiveClass();
                updateAdvancedEditButtons();
            }

            function playCue(id) {
                const cue = cues.find((c) => c.id === id);
                if (!cue || !wavesurfer) return;

                wavesurfer.seekTo(cue.start / wavesurfer.getDuration());
                if (!isPlaying) {
                    wavesurfer.play();
                    isPlaying = true;
                    elements.playBtn.textContent = "â¸ï¸ Pause";
                }
            }

            function clearForm() {
                currentCueId = null;
                activeRegion = null;
                elements.cueStart.value = "";
                elements.cueEnd.value = "";
                elements.cueText.value = "";
                elements.regionColor.value = "#1db954";

                elements.addCue.style.display = "block";
                elements.updateCue.style.display = "none";
                elements.deleteCurrent.style.display = "none";
                elements.cancelEdit.style.display = "none";

                updateActiveClass();
                updateAdvancedEditButtons();
            }

            function updateActiveClass() {
                document.querySelectorAll(".cue-item").forEach((item) => {
                    if (item.dataset.cueId === currentCueId) {
                        item.classList.add("active");
                    } else {
                        item.classList.remove("active");
                    }
                });
            }

            function sortCues() {
                cues.sort((a, b) => a.start - b.start);
            }

            function renderCues() {
                elements.cuesCount.textContent = cues.length;

                if (cues.length === 0) {
                    elements.cuesList.innerHTML = '<div class="no-cues"><p>ðŸŽµ No cue. Import an MP3 and add regions !</p></div>';
                    return;
                }

                const overlaps = detectOverlaps();

                elements.cuesList.innerHTML = "";

                cues.forEach((cue, index) => {
                    // Ensure cue has a color
                    if (!cue.color) {
                        cue.color = generateRandomColor();
                    }

                    const cueEl = document.createElement("div");
                    cueEl.className = "cue-item";
                    cueEl.dataset.cueId = cue.id;
                    cueEl.dataset.id = cue.id; // V3.0 - For goToCue selector
                    cueEl.style.setProperty("--cue-color", cue.color);

                    if (cue.id === currentCueId) {
                        cueEl.classList.add("active");
                    }

                    if (overlaps.includes(cue.id)) {
                        cueEl.classList.add("overlap");
                    }

                    // V3.0 - Add validation class
                    const validationClass = getValidationClass(cue, index);
                    if (validationClass) {
                        cueEl.classList.add(validationClass);
                    }

                    let warningHTML = "";
                    if (overlaps.includes(cue.id)) {
                        warningHTML = '<div class="cue-warning">âš ï¸ Overlap detected</div>';
                    }

                    // V3.0 - Get validation icons
                    const validationIcons = getValidationIconsHTML(cue, index);

                    cueEl.innerHTML = `
                        <div class="cue-item-header">
                            <span class="cue-number">#${index + 1}</span>
                            <div class="cue-header-right">
                                <span class="cue-time">${formatTimeVTT(cue.start)} â†’ ${formatTimeVTT(cue.end)}</span>
                                ${validationIcons}
                            </div>
                        </div>
                        ${warningHTML}
                        <div class="cue-text">${cue.text || '<i style="color:#666;">No text</i>'}</div>
                        <div class="cue-actions-row">
                            <button class="btn btn-secondary play-cue">â–¶ï¸</button>
                            <button class="btn btn-warning edit-cue">âœï¸</button>
                            <button class="btn btn-danger delete-cue">ðŸ—‘ï¸</button>
                        </div>
                    `;

                    cueEl.querySelector(".play-cue").addEventListener("click", (e) => {
                        e.stopPropagation();
                        playCue(cue.id);
                    });

                    cueEl.querySelector(".edit-cue").addEventListener("click", (e) => {
                        e.stopPropagation();
                        editCue(cue.id);
                    });

                    cueEl.querySelector(".delete-cue").addEventListener("click", (e) => {
                        e.stopPropagation();
                        deleteCue(cue.id);
                    });

                    cueEl.addEventListener("click", () => {
                        editCue(cue.id);
                    });

                    elements.cuesList.appendChild(cueEl);
                });

                // V3.0 - Update minimap when cues change
                updateMinimap();
            }

            function markStart() {
                if (!wavesurfer) return;
                const time = wavesurfer.getCurrentTime();
                elements.cueStart.value = time.toFixed(3);
            }

            function markEnd() {
                if (!wavesurfer) return;
                const time = wavesurfer.getCurrentTime();
                elements.cueEnd.value = time.toFixed(3);
            }

            function exportVTT() {
                if (cues.length === 0) {
                    showToast("No cues to export!", "warning");
                    return;
                }

                let vttContent = "WEBVTT\n\n";

                cues.forEach((cue, index) => {
                    vttContent += `cue-${index + 1} [color: ${cue.color}]\n`;
                    vttContent += `${formatTimeVTT(cue.start)} --> ${formatTimeVTT(cue.end)}\n`;
                    vttContent += `${cue.text}\n\n`;
                });

                const blob = new Blob([vttContent], { type: "text/vtt" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = audioFile ? audioFile.name.replace(/\.[^/.]+$/, ".vtt") : "subtitles.vtt";
                a.click();
                URL.revokeObjectURL(url);

                showToast("VTT exported successfully!", "success");
            }

            function clearAllCues() {
                if (confirm("âš ï¸ Delete ALL cues and regions?")) {
                    cues = [];
                    clearAllRegions();
                    renderCues();
                    renderLyrics();
                    clearForm();
                    saveToHistory();
                    showToast("All cues deleted", "info");
                }
            }

            // ===== V2.1 FEATURES =====

            // Feature 1: Enhanced Resize Handles with Tooltips
            function createResizeTooltip() {
                if (!resizeTooltip) {
                    resizeTooltip = document.createElement("div");
                    resizeTooltip.className = "resize-tooltip";
                    document.body.appendChild(resizeTooltip);
                }
                return resizeTooltip;
            }

            function showResizeTooltipDual(x, y, startTime, endTime, isDragging) {
                const tooltip = createResizeTooltip();

                let text = "";
                if (isDragging && startTime !== null && endTime !== null) {
                    // DRAG mode: display both timestamps
                    text = `${formatTimeVTT(startTime)} - ${formatTimeVTT(endTime)}`;
                } else if (startTime !== null && endTime === null) {
                    // START handle mode
                    text = formatTimeVTT(startTime);
                } else if (endTime !== null && startTime === null) {
                    // END handle mode
                    text = formatTimeVTT(endTime);
                } else {
                    // Fallback: display just the start
                    text = formatTimeVTT(startTime || endTime);
                }

                tooltip.textContent = text;

                // Centered horizontally using the transform: translateX(-50%) in the CSS
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y - 80}px`; // 80px above to leave space
                tooltip.classList.add("visible");
            }

            function hideResizeTooltip() {
                if (resizeTooltip) {
                    resizeTooltip.classList.remove("visible");
                }
            }

            // Feature 2: Snap-to-Grid
            function snapToGrid(value) {
                if (!snapEnabled) return value;
                return Math.round(value / snapInterval) * snapInterval;
            }

            function enableSnapToGrid() {
                snapEnabled = elements.snapEnabled.checked;
                // V3.0 - snapInterval is now managed by custom dropdown

                if (snapEnabled) {
                    showToast(`Snap Grid activated (${snapInterval * 1000}ms)`, "success");
                } else {
                    showToast("Snap Grid disabled", "info");
                }
            }

            // Feature 3: Batch Text Editing
            function openBatchModal() {
                elements.batchModal.classList.add("active");
                elements.batchTotalCues.textContent = cues.length;
                elements.batchRange.textContent = "All";
            }

            function closeBatchModal() {
                elements.batchModal.classList.remove("active");
            }

            function parseCueRange(rangeStr) {
                if (rangeStr.toLowerCase() === "all") {
                    return Array.from({ length: cues.length }, (_, i) => i);
                }

                const indices = [];
                const parts = rangeStr.split(",");

                for (let part of parts) {
                    part = part.trim();
                    if (part.includes("-")) {
                        const [start, end] = part.split("-").map((s) => parseInt(s.trim()) - 1);
                        for (let i = start; i <= end && i < cues.length; i++) {
                            if (i >= 0 && !indices.includes(i)) {
                                indices.push(i);
                            }
                        }
                    } else {
                        const idx = parseInt(part) - 1;
                        if (idx >= 0 && idx < cues.length && !indices.includes(idx)) {
                            indices.push(idx);
                        }
                    }
                }

                return indices;
            }

            function batchFindReplace() {
                const findStr = elements.findText.value;
                const replaceStr = elements.replaceText.value;
                const caseSensitive = elements.caseSensitive.checked;

                if (!findStr) {
                    showToast("Enter a text to search", "warning");
                    return;
                }

                let count = 0;
                const flags = caseSensitive ? "g" : "gi";
                const regex = new RegExp(findStr.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), flags);

                cues.forEach((cue) => {
                    if (regex.test(cue.text)) {
                        cue.text = cue.text.replace(regex, replaceStr);
                        count++;
                    }
                });

                if (count > 0) {
                    renderCues();
                    renderLyrics();
                    saveToHistory();
                    showToast(`${count} cues modified`, "success");
                    closeBatchModal();
                } else {
                    showToast("No occurrence found", "warning");
                }
            }

            function batchTransform(type) {
                let count = 0;

                cues.forEach((cue) => {
                    if (cue.text) {
                        switch (type) {
                            case "uppercase":
                                cue.text = cue.text.toUpperCase();
                                break;
                            case "lowercase":
                                cue.text = cue.text.toLowerCase();
                                break;
                            case "capitalize":
                                cue.text = cue.text.replace(/\b\w/g, (c) => c.toUpperCase());
                                break;
                            case "sentence":
                                cue.text = cue.text.charAt(0).toUpperCase() + cue.text.slice(1).toLowerCase();
                                break;
                        }
                        count++;
                    }
                });

                if (count > 0) {
                    renderCues();
                    renderLyrics();
                    saveToHistory();
                    showToast(`${count} cues transformed (${type})`, "success");
                    closeBatchModal();
                }
            }

            function batchModify(mode) {
                const prefix = elements.prefixText.value;
                const suffix = elements.suffixText.value;
                const rangeStr = elements.cueRange.value;

                if (mode === "prefix" && !prefix) {
                    showToast("Enter a prefix", "warning");
                    return;
                }
                if (mode === "suffix" && !suffix) {
                    showToast("Enter a suffix", "warning");
                    return;
                }
                if (mode === "both" && !prefix && !suffix) {
                    showToast("Enter at least a prefix or suffix", "warning");
                    return;
                }

                const indices = parseCueRange(rangeStr);
                let count = 0;

                indices.forEach((idx) => {
                    if (cues[idx]) {
                        if (mode === "prefix" || mode === "both") {
                            cues[idx].text = prefix + cues[idx].text;
                        }
                        if (mode === "suffix" || mode === "both") {
                            cues[idx].text = cues[idx].text + suffix;
                        }
                        count++;
                    }
                });

                if (count > 0) {
                    renderCues();
                    renderLyrics();
                    saveToHistory();
                    showToast(`${count} cues modified`, "success");
                    closeBatchModal();
                }
            }

            // ===== END V2.1 FEATURES =====

            // ===== V2.2 FEATURES =====

            // Feature 1: Waveform Markers/Bookmarks
            function addMarker() {
                if (!wavesurfer) return;

                const time = wavesurfer.getCurrentTime();
                const marker = {
                    id: `marker-${markerIdCounter++}`,
                    time: time,
                    label: `Marker ${markers.length + 1}`,
                    color: "#ff6b6b", // V3.0 - Default marker color
                };

                markers.push(marker);
                renderMarker(marker);
                updateMinimap(); // V3.0
                showToast(`Marker added at ${formatTimeVTT(time)}`, "success");
                updateMarkerButtons();
            }

            function renderMarker(marker) {
                const waveformEl = document.getElementById("waveform");
                if (!waveformEl || !wavesurfer) return;

                const duration = wavesurfer.getDuration();
                const positionPercent = (marker.time / duration) * 100;

                const markerEl = document.createElement("div");
                markerEl.className = "waveform-marker";
                markerEl.dataset.markerId = marker.id;
                markerEl.style.left = `${positionPercent}%`;
                markerEl.style.setProperty("--marker-color", marker.color || "#ff6b6b"); // V3.0
                markerEl.title = `${marker.label} - ${formatTimeVTT(marker.time)} (Double-click to edit)`;

                // V2.2 - Add delete button
                const deleteBtn = document.createElement("button");
                deleteBtn.className = "marker-delete-btn";
                deleteBtn.textContent = "Ã—";
                deleteBtn.title = "Delete Marker";
                deleteBtn.addEventListener("click", (e) => {
                    e.stopPropagation();
                    deleteMarker(marker.id);
                });
                markerEl.appendChild(deleteBtn);

                // Single click to seek
                markerEl.addEventListener("click", () => {
                    wavesurfer.seekTo(marker.time / duration);
                });

                // V3.0 - Double click to edit
                markerEl.addEventListener("dblclick", (e) => {
                    e.stopPropagation();
                    openMarkerEditModal(marker.id);
                });

                markerEl.addEventListener("mouseenter", (e) => {
                    showMarkerTooltip(e.clientX, e.clientY, marker);
                });

                markerEl.addEventListener("mouseleave", () => {
                    hideMarkerTooltip();
                });

                waveformEl.appendChild(markerEl);
            }

            // V3.0 - Re-render all markers
            function renderMarkers() {
                // Remove all existing marker elements
                document.querySelectorAll(".waveform-marker").forEach((el) => el.remove());

                // Re-render each marker
                markers.forEach((marker) => renderMarker(marker));
            }

            let markerTooltip = null;

            function showMarkerTooltip(x, y, marker) {
                if (!markerTooltip) {
                    markerTooltip = document.createElement("div");
                    markerTooltip.className = "marker-tooltip";
                    document.body.appendChild(markerTooltip);
                }

                markerTooltip.textContent = `${marker.label} - ${formatTimeVTT(marker.time)}`;
                markerTooltip.style.display = "block";
                markerTooltip.style.left = `${x}px`;
                markerTooltip.style.top = `${y - 40}px`;
            }

            function hideMarkerTooltip() {
                if (markerTooltip) {
                    markerTooltip.style.display = "none";
                }
            }

            function deleteMarker(markerId) {
                // Hide tooltip first
                hideMarkerTooltip();

                // Remove from array
                markers = markers.filter((m) => m.id !== markerId);

                // Remove from DOM
                const markerEl = document.querySelector(`.waveform-marker[data-marker-id="${markerId}"]`);
                if (markerEl) {
                    markerEl.remove();
                }

                updateMarkerButtons();
                updateMinimap(); // V3.0
                showToast("Marker deleted", "info");
            }

            function clearAllMarkers() {
                if (markers.length === 0) {
                    showToast("No marker to delete", "info");
                    return;
                }

                if (confirm(`Delete all ${markers.length} markers?`)) {
                    // Hide tooltip first
                    hideMarkerTooltip();

                    markers = [];
                    document.querySelectorAll(".waveform-marker").forEach((el) => el.remove());
                    showToast("All markers deleted", "info");
                    updateMarkerButtons();
                    updateMinimap(); // V3.0
                }
            }

            function updateMarkerButtons() {
                elements.clearMarkersBtn.disabled = markers.length === 0;
            }

            function renderAllMarkers() {
                document.querySelectorAll(".waveform-marker").forEach((el) => el.remove());
                markers.forEach((marker) => renderMarker(marker));
            }

            // Feature 2: Multi-Track Support
            function getCurrentTrack() {
                return tracks.find((t) => t.id === currentTrackId) || tracks[0];
            }

            function switchTrack(trackId) {
                // Save current track's cues
                const currentTrack = getCurrentTrack();
                if (currentTrack) {
                    currentTrack.cues = JSON.parse(JSON.stringify(cues));
                }

                // Switch to new track
                currentTrackId = trackId;
                const newTrack = getCurrentTrack();

                if (newTrack) {
                    cues = JSON.parse(JSON.stringify(newTrack.cues));
                    clearAllRegions();
                    rebuildRegions();
                    renderCues();
                    renderLyrics();
                    clearForm();
                    showToast(`Switched to ${newTrack.name}`, "info");
                }
            }

            function createTrack(name) {
                if (!name || name.trim() === "") {
                    showToast("Enter a track name", "warning");
                    return;
                }

                const trackId = `track-${Date.now()}`;
                const newTrack = {
                    id: trackId,
                    name: name.trim(),
                    cues: [],
                    color: generateRandomColor(),
                };

                tracks.push(newTrack);
                renderTrackSelector();
                renderTrackList();
                showToast(`Track "${name}" created`, "success");
            }

            function deleteTrack(trackId) {
                if (trackId === "default") {
                    showToast("Unable to delete the main track", "error");
                    return;
                }

                if (currentTrackId === trackId) {
                    showToast("Unable to delete the active track", "error");
                    return;
                }

                tracks = tracks.filter((t) => t.id !== trackId);
                renderTrackSelector();
                renderTrackList();
                showToast("Track deleted", "info");
            }

            function renderTrackSelector() {
                // V3.0 - Use custom dropdown instead of select
                updateTrackDropdown();
            }

            function renderTrackList() {
                elements.trackList.innerHTML = "";

                tracks.forEach((track) => {
                    const trackEl = document.createElement("div");
                    trackEl.className = "track-item";
                    if (track.id === currentTrackId) {
                        trackEl.classList.add("active");
                    }

                    trackEl.innerHTML = `
                        <div class="track-item-info">
                            <span class="track-indicator" style="background: ${track.color};"></span>
                            <div>
                                <div class="track-item-name">${track.name}</div>
                                <div class="track-item-count">${track.cues.length} cues</div>
                            </div>
                        </div>
                        <div class="track-item-actions">
                            ${
                                track.id !== "default"
                                    ? `
                                <button class="btn btn-danger btn-icon" onclick="deleteTrack('${track.id}')">ðŸ—‘ï¸</button>
                            `
                                    : ""
                            }
                        </div>
                    `;

                    trackEl.addEventListener("click", (e) => {
                        if (!e.target.closest(".track-item-actions")) {
                            switchTrack(track.id);
                            renderTrackList();
                        }
                    });

                    elements.trackList.appendChild(trackEl);
                });
            }

            function openTrackModal() {
                elements.trackModal.classList.add("active");
                renderTrackList();
            }

            function closeTrackModal() {
                elements.trackModal.classList.remove("active");
            }

            // Feature 3: Export to SRT Format
            function formatTimeSRT(seconds) {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);

                return `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")},${ms.toString().padStart(3, "0")}`;
            }

            function exportSRT() {
                if (cues.length === 0) {
                    showToast("No cues to export!", "warning");
                    return;
                }

                let srtContent = "";

                cues.forEach((cue, index) => {
                    srtContent += `${index + 1}\n`;
                    srtContent += `${formatTimeSRT(cue.start)} --> ${formatTimeSRT(cue.end)}\n`;
                    srtContent += `${cue.text}\n\n`;
                });

                const blob = new Blob([srtContent], { type: "text/srt" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = audioFile ? audioFile.name.replace(/\.[^/.]+$/, ".srt") : "subtitles.srt";
                a.click();
                URL.revokeObjectURL(url);

                showToast("SRT exported successfully!", "success");
            }

            // ===== END V2.2 FEATURES =====

            // ===== V3.0 FEATURES =====

            // Feature 1: Export Dropdown Toggle
            function toggleExportDropdown() {
                elements.exportDropdown.classList.toggle("active");
            }

            function closeExportDropdown() {
                elements.exportDropdown.classList.remove("active");
            }

            // Close dropdown when clicking outside
            document.addEventListener("click", (e) => {
                if (!elements.exportDropdown.contains(e.target)) {
                    closeExportDropdown();
                }
            });

            // Feature 2: Export ASS/SSA Format
            function formatTimeASS(seconds) {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const centis = Math.floor((seconds % 1) * 100);

                return `${hours}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}.${centis.toString().padStart(2, "0")}`;
            }

            function exportASS() {
                if (cues.length === 0) {
                    showToast("No cues to export!", "warning");
                    return;
                }

                // ASS Header
                let assContent = `[Script Info]
Title: Exported from VTT Editor Pro V3.0
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,48,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,-1,0,0,0,100,100,0,0,1,2,1,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

                cues.forEach((cue) => {
                    // Remove any HTML tags and convert newlines
                    const cleanText = cue.text.replace(/<[^>]*>/g, "").replace(/\n/g, "\\N");
                    assContent += `Dialogue: 0,${formatTimeASS(cue.start)},${formatTimeASS(cue.end)},Default,,0,0,0,,${cleanText}\n`;
                });

                const blob = new Blob([assContent], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = audioFile ? audioFile.name.replace(/\.[^/.]+$/, ".ass") : "subtitles.ass";
                a.click();
                URL.revokeObjectURL(url);

                closeExportDropdown();
                showToast("ASS exported successfully!", "success");
            }

            // Feature 3: Export SBV Format (YouTube)
            function formatTimeSBV(seconds) {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);

                return `${hours}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}.${ms.toString().padStart(3, "0")}`;
            }

            function exportSBV() {
                if (cues.length === 0) {
                    showToast("No cues to export!", "warning");
                    return;
                }

                let sbvContent = "";

                cues.forEach((cue) => {
                    sbvContent += `${formatTimeSBV(cue.start)},${formatTimeSBV(cue.end)}\n`;
                    sbvContent += `${cue.text}\n\n`;
                });

                const blob = new Blob([sbvContent], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = audioFile ? audioFile.name.replace(/\.[^/.]+$/, ".sbv") : "subtitles.sbv";
                a.click();
                URL.revokeObjectURL(url);

                closeExportDropdown();
                showToast("SBV (YouTube) exported successfully!", "success");
            }

            // Feature: Export DFXP/TTML
            function formatTimeDFXP(seconds) {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);

                return `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}.${ms.toString().padStart(3, "0")}`;
            }

            function exportDFXP() {
                if (cues.length === 0) {
                    showToast("No cues to export!", "warning");
                    return;
                }

                // Escape XML special characters
                function escapeXml(text) {
                    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
                }

                let dfxpContent = `<?xml version="1.0" encoding="UTF-8"?>
<tt xmlns="http://www.w3.org/ns/ttml" xmlns:tts="http://www.w3.org/ns/ttml#styling" xml:lang="fr">
  <head>
    <styling>
      <style xml:id="defaultStyle" tts:fontFamily="Arial" tts:fontSize="100%" tts:textAlign="center"/>
    </styling>
    <layout>
      <region xml:id="bottom" tts:origin="10% 80%" tts:extent="80% 20%" tts:textAlign="center" tts:displayAlign="after"/>
    </layout>
  </head>
  <body>
    <div region="bottom">
`;

                cues.forEach((cue) => {
                    const text = escapeXml(cue.text).replace(/\n/g, "<br/>");
                    dfxpContent += `      <p begin="${formatTimeDFXP(cue.start)}" end="${formatTimeDFXP(cue.end)}">${text}</p>\n`;
                });

                dfxpContent += `    </div>
  </body>
</tt>`;

                const blob = new Blob([dfxpContent], { type: "application/ttml+xml" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = audioFile ? audioFile.name.replace(/\.[^/.]+$/, ".dfxp") : "subtitles.dfxp";
                a.click();
                URL.revokeObjectURL(url);

                closeExportDropdown();
                showToast("DFXP/TTML exported successfully!", "success");
            }

            // Feature 4: Export JSON (Complete Backup)
            function exportJSON() {
                // Save current track's cues before export
                const currentTrack = getCurrentTrack();
                if (currentTrack) {
                    currentTrack.cues = JSON.parse(JSON.stringify(cues));
                }

                const exportData = {
                    version: "3.0",
                    exportDate: new Date().toISOString(),
                    audioFileName: audioFile ? audioFile.name : null,
                    tracks: tracks,
                    markers: markers,
                    currentTrackId: currentTrackId,
                    settings: {
                        allowOverlap: allowOverlap,
                        snapEnabled: snapEnabled,
                        snapInterval: snapInterval,
                    },
                };

                const jsonContent = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonContent], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = audioFile ? audioFile.name.replace(/\.[^/.]+$/, "-backup.json") : "vtt-editor-backup.json";
                a.click();
                URL.revokeObjectURL(url);

                closeExportDropdown();
                showToast("JSON backup exported successfully!", "success");
            }

            // Feature 5: Import Dropdown Toggle
            function toggleImportDropdown() {
                elements.importDropdown.classList.toggle("active");
            }

            function closeImportDropdown() {
                elements.importDropdown.classList.remove("active");
            }

            // Close import dropdown when clicking outside
            document.addEventListener("click", (e) => {
                if (!elements.importDropdown.contains(e.target)) {
                    closeImportDropdown();
                }
            });

            // Feature 6: Parse ASS/SSA Format
            function parseASS(content) {
                const lines = content.split("\n");
                const parsedCues = [];
                let inEvents = false;
                let formatFields = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    // Check if we're in the Events section
                    if (line === "[Events]") {
                        inEvents = true;
                        continue;
                    }

                    // Check for section change
                    if (line.startsWith("[") && line !== "[Events]") {
                        inEvents = false;
                        continue;
                    }

                    if (!inEvents) continue;

                    // Parse Format line
                    if (line.startsWith("Format:")) {
                        formatFields = line
                            .substring(7)
                            .split(",")
                            .map((f) => f.trim().toLowerCase());
                        continue;
                    }

                    // Parse Dialogue lines
                    if (line.startsWith("Dialogue:")) {
                        const dialogueContent = line.substring(9);
                        const values = [];
                        let currentValue = "";
                        let fieldIndex = 0;

                        // Parse comma-separated values, but Text field can contain commas
                        for (let j = 0; j < dialogueContent.length; j++) {
                            if (dialogueContent[j] === "," && fieldIndex < formatFields.length - 1) {
                                values.push(currentValue.trim());
                                currentValue = "";
                                fieldIndex++;
                            } else {
                                currentValue += dialogueContent[j];
                            }
                        }
                        values.push(currentValue.trim()); // Last field (Text)

                        const startIndex = formatFields.indexOf("start");
                        const endIndex = formatFields.indexOf("end");
                        const textIndex = formatFields.indexOf("text");

                        if (startIndex !== -1 && endIndex !== -1 && textIndex !== -1) {
                            const start = parseASSTime(values[startIndex]);
                            const end = parseASSTime(values[endIndex]);
                            let text = values[textIndex];

                            // Clean ASS formatting codes
                            text = text.replace(/\{[^}]*\}/g, ""); // Remove {...} tags
                            text = text.replace(/\\N/g, "\n"); // Convert line breaks
                            text = text.replace(/\\n/g, "\n");

                            if (start !== null && end !== null && text) {
                                parsedCues.push({
                                    id: generateCueId(),
                                    start: start,
                                    end: end,
                                    text: text.trim(),
                                    color: generateRandomColor(),
                                });
                            }
                        }
                    }
                }

                return parsedCues;
            }

            function parseASSTime(timeStr) {
                // ASS time format: H:MM:SS.CC (centiseconds)
                const parts = timeStr.split(":");
                if (parts.length === 3) {
                    const hours = parseInt(parts[0]);
                    const minutes = parseInt(parts[1]);
                    const secondsParts = parts[2].split(".");
                    const seconds = parseInt(secondsParts[0]);
                    const centiseconds = parseInt(secondsParts[1] || 0);
                    return hours * 3600 + minutes * 60 + seconds + centiseconds / 100;
                }
                return null;
            }

            // Feature 7: Parse SBV Format (YouTube)
            function parseSBV(content) {
                const lines = content.split("\n");
                const parsedCues = [];
                let i = 0;

                while (i < lines.length) {
                    const line = lines[i].trim();

                    // SBV format: start,end on one line
                    if (line.includes(",") && line.match(/^\d+:\d+:\d+\.\d+,\d+:\d+:\d+\.\d+$/)) {
                        const timeParts = line.split(",");
                        const start = parseSBVTime(timeParts[0].trim());
                        const end = parseSBVTime(timeParts[1].trim());

                        i++;
                        let text = "";
                        // Read all text lines until empty line or next timestamp
                        while (i < lines.length && lines[i].trim() !== "" && !lines[i].trim().match(/^\d+:\d+:\d+\.\d+,/)) {
                            text += lines[i].trim() + " ";
                            i++;
                        }

                        if (start !== null && end !== null && text.trim()) {
                            parsedCues.push({
                                id: generateCueId(),
                                start: start,
                                end: end,
                                text: text.trim(),
                                color: generateRandomColor(),
                            });
                        }
                    } else {
                        i++;
                    }
                }

                return parsedCues;
            }

            function parseSBVTime(timeStr) {
                // SBV format: H:MM:SS.mmm
                const parts = timeStr.split(":");
                if (parts.length === 3) {
                    const hours = parseInt(parts[0]);
                    const minutes = parseInt(parts[1]);
                    const seconds = parseFloat(parts[2]);
                    return hours * 3600 + minutes * 60 + seconds;
                }
                return null;
            }

            // Feature: Import DFXP/TTML
            function parseDFXP(content) {
                const parsedCues = [];

                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(content, "text/xml");

                    // Check for parsing errors
                    const parseError = xmlDoc.querySelector("parsererror");
                    if (parseError) {
                        showToast("XML parsing error", "error");
                        return parsedCues;
                    }

                    // Find all <p> elements (subtitle entries)
                    const paragraphs = xmlDoc.querySelectorAll("p");

                    paragraphs.forEach((p, index) => {
                        const begin = p.getAttribute("begin");
                        const end = p.getAttribute("end");
                        const dur = p.getAttribute("dur");

                        if (begin) {
                            const startTime = parseDFXPTime(begin);
                            let endTime;

                            if (end) {
                                endTime = parseDFXPTime(end);
                            } else if (dur) {
                                endTime = startTime + parseDFXPTime(dur);
                            } else {
                                endTime = startTime + 2; // Default 2 second duration
                            }

                            // Get text content, handling <br/> tags
                            let text = "";
                            p.childNodes.forEach((node) => {
                                if (node.nodeType === Node.TEXT_NODE) {
                                    text += node.textContent;
                                } else if (node.nodeName.toLowerCase() === "br") {
                                    text += "\n";
                                } else if (node.nodeType === Node.ELEMENT_NODE) {
                                    text += node.textContent;
                                }
                            });
                            text = text.trim();

                            if (startTime !== null && endTime !== null && text) {
                                parsedCues.push({
                                    id: `cue-${Date.now()}-${index}`,
                                    start: startTime,
                                    end: endTime,
                                    text: text,
                                    color: generateRandomColor(),
                                });
                            }
                        }
                    });
                } catch (e) {
                    console.error("DFXP parsing error:", e);
                    showToast("Error parsing DFXP", "error");
                }

                return parsedCues;
            }

            function parseDFXPTime(timeStr) {
                if (!timeStr) return null;

                // Handle different DFXP time formats:
                // 1. Clock time: HH:MM:SS.mmm or HH:MM:SS:ff (frames)
                // 2. Offset time: 10s, 10.5s, 100ms, 10h, 10m
                // 3. Frames: 100f (depends on frame rate)

                // Check for offset time format (e.g., "10s", "100ms")
                const offsetMatch = timeStr.match(/^(\d+\.?\d*)(h|m|s|ms|f)$/);
                if (offsetMatch) {
                    const value = parseFloat(offsetMatch[1]);
                    const unit = offsetMatch[2];
                    switch (unit) {
                        case "h":
                            return value * 3600;
                        case "m":
                            return value * 60;
                        case "s":
                            return value;
                        case "ms":
                            return value / 1000;
                        case "f":
                            return value / 30; // Assume 30fps
                        default:
                            return value;
                    }
                }

                // Clock time format: HH:MM:SS.mmm or HH:MM:SS:ff
                const clockMatch = timeStr.match(/^(\d+):(\d+):(\d+)([\.:](\d+))?$/);
                if (clockMatch) {
                    const hours = parseInt(clockMatch[1]);
                    const minutes = parseInt(clockMatch[2]);
                    const seconds = parseInt(clockMatch[3]);
                    let fraction = 0;

                    if (clockMatch[5]) {
                        const fractionStr = clockMatch[5];
                        if (clockMatch[4] === ":") {
                            // Frame-based: assume 30fps
                            fraction = parseInt(fractionStr) / 30;
                        } else {
                            // Milliseconds
                            fraction = parseInt(fractionStr) / Math.pow(10, fractionStr.length);
                        }
                    }

                    return hours * 3600 + minutes * 60 + seconds + fraction;
                }

                return null;
            }

            // Feature 8: Import JSON Backup
            function importJSON(content) {
                try {
                    const data = JSON.parse(content);

                    // Validate JSON structure
                    if (!data.version || !data.tracks) {
                        showToast("Invalid JSON format - not a VTT Editor backup", "error");
                        return false;
                    }

                    // Confirm import
                    const cuesCount = data.tracks.reduce((sum, t) => sum + (t.cues ? t.cues.length : 0), 0);
                    const markersCount = data.markers ? data.markers.length : 0;
                    const tracksCount = data.tracks.length;

                    if (!confirm(`Import this backup?\n\n- ${tracksCount} tracks\n- ${cuesCount} cues total\n- ${markersCount} markers\n\nâš ï¸ This will replace current data.`)) {
                        return false;
                    }

                    // Import tracks
                    tracks = data.tracks;
                    currentTrackId = data.currentTrackId || "default";

                    // Ensure all cues have colors (for backwards compatibility)
                    tracks.forEach((track) => {
                        if (track.cues) {
                            track.cues.forEach((cue) => {
                                if (!cue.color) {
                                    cue.color = generateRandomColor();
                                }
                            });
                        }
                    });

                    // Load current track's cues
                    const currentTrack = getCurrentTrack();
                    if (currentTrack) {
                        cues = currentTrack.cues || [];
                    }

                    // Import markers
                    if (data.markers) {
                        markers = data.markers;
                        markerIdCounter = Math.max(...markers.map((m) => parseInt(m.id.split("-")[1]) || 0), 0) + 1;
                    }

                    // Import settings
                    if (data.settings) {
                        if (data.settings.allowOverlap !== undefined) {
                            allowOverlap = data.settings.allowOverlap;
                            elements.allowOverlap.checked = allowOverlap;
                        }
                        if (data.settings.snapEnabled !== undefined) {
                            snapEnabled = data.settings.snapEnabled;
                            elements.snapEnabled.checked = snapEnabled;
                        }
                        if (data.settings.snapInterval !== undefined) {
                            snapInterval = data.settings.snapInterval;
                            // V3.0 - Update custom dropdown label
                            updateSnapDropdownLabel(snapInterval);
                        }
                    }

                    // Rebuild UI
                    renderTrackSelector();
                    rebuildRegions();
                    renderCues();
                    renderLyrics();
                    renderAllMarkers();
                    updateMarkerButtons();
                    saveToHistory();

                    return true;
                } catch (e) {
                    console.error("JSON import error:", e);
                    showToast("Error parsing JSON", "error");
                    return false;
                }
            }

            // Feature 9: Split Cue at cursor position
            function splitCue() {
                if (!currentCueId || !wavesurfer) {
                    showToast("Select a cue to split", "warning");
                    return;
                }

                const cue = cues.find((c) => c.id === currentCueId);
                if (!cue) {
                    showToast("Cue not found", "error");
                    return;
                }

                const currentTime = wavesurfer.getCurrentTime();

                // Check if cursor is within the cue
                if (currentTime <= cue.start || currentTime >= cue.end) {
                    showToast("Place the cursor inside the cue to split it", "warning");
                    return;
                }

                // Minimum duration check (0.1s)
                const minDuration = 0.1;
                if (currentTime - cue.start < minDuration || cue.end - currentTime < minDuration) {
                    showToast("This split would create a cue shorter than 0.1s", "warning");
                    return;
                }

                // Create two new cues
                const cue1 = {
                    id: generateCueId(),
                    start: cue.start,
                    end: currentTime,
                    text: cue.text,
                    color: cue.color,
                };

                const cue2 = {
                    id: generateCueId(),
                    start: currentTime,
                    end: cue.end,
                    text: "",
                    color: generateRandomColor(),
                };

                // Remove old cue and add new ones
                const cueIndex = cues.findIndex((c) => c.id === currentCueId);
                cues.splice(cueIndex, 1, cue1, cue2);

                // Update regions
                deleteRegion(currentCueId);
                createRegion(cue1.start, cue1.end, cue1.color, cue1.id);
                createRegion(cue2.start, cue2.end, cue2.color, cue2.id);

                // Select the second cue for editing
                currentCueId = cue2.id;
                elements.cueStart.value = cue2.start.toFixed(3);
                elements.cueEnd.value = cue2.end.toFixed(3);
                elements.cueText.value = cue2.text;
                elements.regionColor.value = cue2.color;

                elements.addCue.style.display = "none";
                elements.updateCue.style.display = "block";
                elements.deleteCurrent.style.display = "block";
                elements.cancelEdit.style.display = "block";

                sortCues();
                renderCues();
                renderLyrics();
                saveToHistory();
                updateAdvancedEditButtons();

                showToast("Cue split in 2! Edit the text of the 2nd cue.", "success");
                elements.cueText.focus();
            }

            // Feature 10: Merge two consecutive cues
            function mergeCues() {
                if (!currentCueId) {
                    showToast("Select a cue to merge with the next one", "warning");
                    return;
                }

                const currentIndex = cues.findIndex((c) => c.id === currentCueId);
                if (currentIndex === -1) {
                    showToast("Cue not found", "error");
                    return;
                }

                if (currentIndex >= cues.length - 1) {
                    showToast("No next cue to merge with", "warning");
                    return;
                }

                const cue1 = cues[currentIndex];
                const cue2 = cues[currentIndex + 1];

                // Check if they are consecutive (gap < 1s)
                const gap = cue2.start - cue1.end;
                if (gap > 1) {
                    if (!confirm(`The cues have a gap of ${gap.toFixed(2)}s. Merge anyway?`)) {
                        return;
                    }
                }

                // Create merged cue
                const mergedCue = {
                    id: generateCueId(),
                    start: cue1.start,
                    end: cue2.end,
                    text: cue1.text + (cue1.text && cue2.text ? "\n" : "") + cue2.text,
                    color: cue1.color,
                };

                // Remove old cues and add merged
                cues.splice(currentIndex, 2, mergedCue);

                // Update regions
                deleteRegion(cue1.id);
                deleteRegion(cue2.id);
                createRegion(mergedCue.start, mergedCue.end, mergedCue.color, mergedCue.id);

                // Select merged cue
                currentCueId = mergedCue.id;
                elements.cueStart.value = mergedCue.start.toFixed(3);
                elements.cueEnd.value = mergedCue.end.toFixed(3);
                elements.cueText.value = mergedCue.text;
                elements.regionColor.value = mergedCue.color;

                elements.addCue.style.display = "none";
                elements.updateCue.style.display = "block";
                elements.deleteCurrent.style.display = "block";
                elements.cancelEdit.style.display = "block";

                renderCues();
                renderLyrics();
                saveToHistory();
                updateAdvancedEditButtons();

                showToast("Cues merged!", "success");
            }

            // Feature 11: Shift All Timings
            let shiftAmount = 0;

            function openShiftModal() {
                shiftAmount = 0;
                elements.shiftValue.value = "0";
                updateShiftPreview();
                elements.shiftCuesCount.textContent = cues.length;
                elements.shiftModal.classList.add("active");
            }

            function closeShiftModal() {
                elements.shiftModal.classList.remove("active");
            }

            function updateShiftPreview() {
                const value = parseFloat(elements.shiftValue.value) || 0;
                shiftAmount = value;

                const prefix = value >= 0 ? "+" : "";
                elements.shiftPreviewValue.textContent = `${prefix}${value.toFixed(3)}s`;

                // Update color class
                elements.shiftPreviewValue.classList.remove("positive", "negative");
                if (value > 0) {
                    elements.shiftPreviewValue.classList.add("positive");
                } else if (value < 0) {
                    elements.shiftPreviewValue.classList.add("negative");
                }
            }

            function adjustShift(delta) {
                const currentValue = parseFloat(elements.shiftValue.value) || 0;
                const newValue = Math.round((currentValue + delta) * 1000) / 1000;
                elements.shiftValue.value = newValue;
                updateShiftPreview();
            }

            function setShiftValue(value) {
                elements.shiftValue.value = value;
                updateShiftPreview();
            }

            function applyShift() {
                const shiftSeconds = parseFloat(elements.shiftValue.value) || 0;

                if (shiftSeconds === 0) {
                    showToast("No shift to apply", "info");
                    closeShiftModal();
                    return;
                }

                if (cues.length === 0) {
                    showToast("No cues to shift", "warning");
                    closeShiftModal();
                    return;
                }

                // Check if shift would make any cue negative
                const minStart = Math.min(...cues.map((c) => c.start));
                if (minStart + shiftSeconds < 0) {
                    showToast(`Shift too negative! The first cue would start at ${(minStart + shiftSeconds).toFixed(3)}s`, "error");
                    return;
                }

                // Apply shift to all cues
                cues.forEach((cue) => {
                    cue.start = Math.max(0, cue.start + shiftSeconds);
                    cue.end = Math.max(0, cue.end + shiftSeconds);
                });

                // Rebuild regions
                rebuildRegions();
                renderCues();
                renderLyrics();
                saveToHistory();

                closeShiftModal();
                showToast(`${cues.length} cues shifted by ${shiftSeconds > 0 ? "+" : ""}${shiftSeconds.toFixed(3)}s`, "success");
            }

            // Update advanced edit buttons state
            function updateAdvancedEditButtons() {
                const hasCues = cues.length > 0;
                const hasSelection = currentCueId !== null;
                const hasNextCue = hasSelection && cues.findIndex((c) => c.id === currentCueId) < cues.length - 1;

                elements.splitCueBtn.disabled = !hasSelection;
                elements.mergeCuesBtn.disabled = !hasSelection || !hasNextCue;
                elements.shiftTimingsBtn.disabled = !hasCues;
            }

            // Feature 12: Search in Cues
            let currentSearchQuery = "";

            function searchCues(query) {
                currentSearchQuery = query.trim().toLowerCase();

                // Show/hide clear button
                if (currentSearchQuery) {
                    elements.searchClear.classList.add("visible");
                } else {
                    elements.searchClear.classList.remove("visible");
                }

                // Get all cue items
                const cueItems = document.querySelectorAll(".cue-item");
                let visibleCount = 0;

                cueItems.forEach((item) => {
                    const cueId = item.dataset.cueId;
                    const cue = cues.find((c) => c.id === cueId);

                    if (!cue) return;

                    if (!currentSearchQuery) {
                        // No search - show all
                        item.classList.remove("search-hidden");
                        // Remove highlights
                        const textEl = item.querySelector(".cue-text");
                        if (textEl && cue) {
                            textEl.textContent = cue.text || "(empty)";
                        }
                        visibleCount++;
                    } else {
                        // Check if text matches
                        const text = cue.text.toLowerCase();
                        if (text.includes(currentSearchQuery)) {
                            item.classList.remove("search-hidden");
                            // Add highlight
                            const textEl = item.querySelector(".cue-text");
                            if (textEl) {
                                textEl.innerHTML = highlightText(cue.text, currentSearchQuery);
                            }
                            visibleCount++;
                        } else {
                            item.classList.add("search-hidden");
                        }
                    }
                });

                // Update results count
                updateSearchResultsCount(visibleCount, cues.length);
            }

            function highlightText(text, query) {
                if (!query) return escapeHtml(text);

                const regex = new RegExp(`(${escapeRegex(query)})`, "gi");
                return escapeHtml(text).replace(regex, '<span class="search-highlight">$1</span>');
            }

            function escapeHtml(text) {
                const div = document.createElement("div");
                div.textContent = text;
                return div.innerHTML;
            }

            function escapeRegex(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }

            function updateSearchResultsCount(visible, total) {
                if (!currentSearchQuery) {
                    elements.searchResultsCount.textContent = "";
                    elements.searchResultsCount.classList.remove("has-results");
                } else {
                    elements.searchResultsCount.textContent = `${visible} / ${total} cues found`;
                    if (visible > 0) {
                        elements.searchResultsCount.classList.add("has-results");
                    } else {
                        elements.searchResultsCount.classList.remove("has-results");
                    }
                }
            }

            function clearSearch() {
                elements.cueSearch.value = "";
                searchCues("");
                elements.cueSearch.focus();
            }

            // Feature 13: Go to Time
            function parseTimeInput(input) {
                input = input.trim();

                // Format: MM:SS.mmm or M:SS.mmm
                if (input.includes(":")) {
                    const parts = input.split(":");
                    if (parts.length === 2) {
                        const mins = parseInt(parts[0]) || 0;
                        const secs = parseFloat(parts[1]) || 0;
                        return mins * 60 + secs;
                    } else if (parts.length === 3) {
                        // HH:MM:SS.mmm
                        const hours = parseInt(parts[0]) || 0;
                        const mins = parseInt(parts[1]) || 0;
                        const secs = parseFloat(parts[2]) || 0;
                        return hours * 3600 + mins * 60 + secs;
                    }
                }

                // Format: just seconds (e.g., "45.5" or "125")
                const secs = parseFloat(input);
                if (!isNaN(secs)) {
                    return secs;
                }

                return null;
            }

            function goToTime() {
                if (!wavesurfer) {
                    showToast("First, load an audio file", "warning");
                    return;
                }

                const input = elements.gotoTimeInput.value;
                const time = parseTimeInput(input);

                if (time === null || isNaN(time)) {
                    showToast("Invalid format. Use MM:SS.mmm or seconds", "error");
                    return;
                }

                const duration = wavesurfer.getDuration();

                if (time < 0) {
                    showToast("Time cannot be negative", "error");
                    return;
                }

                if (time > duration) {
                    showToast(`Time exceeds duration (${formatTime(duration)})`, "warning");
                    wavesurfer.seekTo(1);
                } else {
                    wavesurfer.seekTo(time / duration);
                    showToast(`Position: ${formatTimeVTT(time)}`, "success");
                }

                // Clear input
                elements.gotoTimeInput.value = "";
            }

            // V3.0 - Stats & Validation
            const VALIDATION_RULES = {
                minDuration: 0.5, // Time minimum en secondes
                maxDuration: 10, // Time maximum en secondes
                maxCharsPerLine: 42, // Maximum characters per line (Netflix standard)
                maxTotalChars: 84, // Maximum characters total (2 lines)
                minCPS: 5, // Characters per second minimum
                maxCPS: 25, // Characters per second maximum (readability)
            };

            function calculateStats() {
                if (cues.length === 0) {
                    updateStatsDisplay({
                        totalCues: 0,
                        totalDuration: 0,
                        avgDuration: 0,
                        totalWords: 0,
                        wpm: 0,
                        totalChars: 0,
                    });
                    return;
                }

                const cuesList = cues;
                let totalDuration = 0;
                let totalWords = 0;
                let totalChars = 0;

                cuesList.forEach((cue) => {
                    const duration = cue.end - cue.start;
                    totalDuration += duration;

                    const text = cue.text || "";
                    totalChars += text.length;

                    // Count words (split by whitespace)
                    const words = text
                        .trim()
                        .split(/\s+/)
                        .filter((w) => w.length > 0);
                    totalWords += words.length;
                });

                const avgDuration = cuesList.length > 0 ? totalDuration / cuesList.length : 0;
                const wpm = totalDuration > 0 ? Math.round((totalWords / totalDuration) * 60) : 0;

                const stats = {
                    totalCues: cuesList.length,
                    totalDuration: totalDuration,
                    avgDuration: avgDuration,
                    totalWords: totalWords,
                    wpm: wpm,
                    totalChars: totalChars,
                };

                updateStatsDisplay(stats);
                return stats;
            }

            function updateStatsDisplay(stats) {
                const elements = {
                    totalCues: document.getElementById("stat-total-cues"),
                    totalDuration: document.getElementById("stat-total-duration"),
                    avgDuration: document.getElementById("stat-avg-duration"),
                    totalWords: document.getElementById("stat-total-words"),
                    wpm: document.getElementById("stat-wpm"),
                    totalChars: document.getElementById("stat-total-chars"),
                };

                if (elements.totalCues) elements.totalCues.textContent = stats.totalCues;
                if (elements.totalDuration) elements.totalDuration.textContent = formatTime(stats.totalDuration);
                if (elements.avgDuration) elements.avgDuration.textContent = stats.avgDuration.toFixed(1) + "s";
                if (elements.totalWords) elements.totalWords.textContent = stats.totalWords;
                if (elements.wpm) {
                    elements.wpm.textContent = stats.wpm;
                    // Color coding for WPM
                    const wpmEl = elements.wpm.parentElement;
                    wpmEl.classList.remove("warning", "error");
                    if (stats.wpm > 180) {
                        wpmEl.classList.add("error");
                    } else if (stats.wpm > 160) {
                        wpmEl.classList.add("warning");
                    }
                }
                if (elements.totalChars) elements.totalChars.textContent = stats.totalChars;
            }

            function validateCue(cue, index) {
                const issues = [];
                const duration = cue.end - cue.start;
                const text = cue.text || "";
                const lines = text.split("\n");
                const totalChars = text.replace(/\n/g, "").length;
                const cps = duration > 0 ? totalChars / duration : 0;

                // Duration checks
                if (duration < VALIDATION_RULES.minDuration) {
                    issues.push({
                        type: "error",
                        code: "duration_short",
                        message: `Duration too short (${duration.toFixed(2)}s < ${VALIDATION_RULES.minDuration}s)`,
                    });
                }

                if (duration > VALIDATION_RULES.maxDuration) {
                    issues.push({
                        type: "warning",
                        code: "duration_long",
                        message: `Duration too long (${duration.toFixed(1)}s > ${VALIDATION_RULES.maxDuration}s)`,
                    });
                }

                // Characters per line check
                lines.forEach((line, lineIndex) => {
                    if (line.length > VALIDATION_RULES.maxCharsPerLine) {
                        issues.push({
                            type: "warning",
                            code: "line_too_long",
                            message: `Line ${lineIndex + 1}: ${line.length} chars (max: ${VALIDATION_RULES.maxCharsPerLine})`,
                        });
                    }
                });

                // Total characters check
                if (totalChars > VALIDATION_RULES.maxTotalChars) {
                    issues.push({
                        type: "warning",
                        code: "text_too_long",
                        message: `Text too long (${totalChars} > ${VALIDATION_RULES.maxTotalChars} chars)`,
                    });
                }

                // Reading speed (CPS) check
                if (cps > VALIDATION_RULES.maxCPS) {
                    issues.push({
                        type: "error",
                        code: "cps_high",
                        message: `Too fast: ${cps.toFixed(1)} chars/s (max: ${VALIDATION_RULES.maxCPS})`,
                    });
                }

                // Empty text check
                if (text.trim().length === 0) {
                    issues.push({
                        type: "error",
                        code: "empty_text",
                        message: "Empty text",
                    });
                }

                return issues;
            }

            function validateAllCues() {
                if (cues.length === 0) {
                    updateValidationDisplay([], 0, 0);
                    return [];
                }

                const allIssues = [];
                let warningCount = 0;
                let errorCount = 0;

                cues.forEach((cue, index) => {
                    const issues = validateCue(cue, index);
                    if (issues.length > 0) {
                        allIssues.push({
                            cueIndex: index,
                            cueId: cue.id,
                            start: cue.start,
                            issues: issues,
                        });

                        issues.forEach((issue) => {
                            if (issue.type === "error") errorCount++;
                            else warningCount++;
                        });
                    }
                });

                updateValidationDisplay(allIssues, warningCount, errorCount);
                return allIssues;
            }

            function updateValidationDisplay(allIssues, warningCount, errorCount) {
                const summaryEl = document.getElementById("validation-summary");
                const listEl = document.getElementById("validation-list");

                if (!summaryEl || !listEl) return;

                // Update summary badges
                if (warningCount === 0 && errorCount === 0) {
                    summaryEl.innerHTML = '<span class="validation-badge success">âœ“ No issues</span>';
                } else {
                    let badges = "";
                    if (errorCount > 0) {
                        badges += `<span class="validation-badge errors">âœ• ${errorCount} error${errorCount > 1 ? "s" : ""}</span>`;
                    }
                    if (warningCount > 0) {
                        badges += `<span class="validation-badge warnings">âš  ${warningCount} warning${warningCount > 1 ? "s" : ""}</span>`;
                    }
                    summaryEl.innerHTML = badges;
                }

                // Update issues list (show first 10 issues max)
                const displayIssues = allIssues.slice(0, 10);
                listEl.innerHTML = displayIssues
                    .map((item) => {
                        return item.issues
                            .map(
                                (issue) => `
            <div class="validation-item" onclick="goToCue(${item.cueIndex})">
                <span class="icon">${issue.type === "error" ? "âŒ" : "âš ï¸"}</span>
                <span class="cue-ref">#${item.cueIndex + 1}</span>
                <span class="message">${issue.message}</span>
            </div>
        `
                            )
                            .join("");
                    })
                    .join("");

                if (allIssues.length > 10) {
                    listEl.innerHTML += `<div class="validation-item" style="justify-content: center; color: #666;">
            ... and ${allIssues.length - 10} other issues
        </div>`;
                }
            }

            function goToCue(index) {
                if (!cues[index]) return;

                // Close stats modal if open
                closeStatsModal();

                const cue = cues[index];

                // Select the cue
                currentCueId = cue.id;

                // Seek to cue start
                if (wavesurfer) {
                    const duration = wavesurfer.getDuration();
                    if (duration > 0) {
                        wavesurfer.seekTo(cue.start / duration);
                    }
                }

                // Render and scroll to cue
                renderCues();

                // Scroll cue into view within the cues-list container only
                setTimeout(() => {
                    const cueEl = document.querySelector(`.cue-item[data-id="${cue.id}"]`);
                    const container = document.getElementById("cues-list");
                    if (cueEl && container) {
                        const containerRect = container.getBoundingClientRect();
                        const cueRect = cueEl.getBoundingClientRect();
                        const scrollTop = container.scrollTop + (cueRect.top - containerRect.top) - containerRect.height / 2 + cueRect.height / 2;
                        container.scrollTo({ top: scrollTop, behavior: "smooth" });
                    }
                }, 100);
            }

            function getValidationIconsHTML(cue, index) {
                const issues = validateCue(cue, index);
                if (issues.length === 0) return "";

                const hasError = issues.some((i) => i.type === "error");
                const hasWarning = issues.some((i) => i.type === "warning");

                let html = '<div class="validation-icons">';

                if (hasError) {
                    const errorMsg = issues
                        .filter((i) => i.type === "error")
                        .map((i) => i.message)
                        .join(" | ");
                    html += `<span class="validation-icon error" data-tooltip="${errorMsg}">!</span>`;
                }

                if (hasWarning) {
                    const warnMsg = issues
                        .filter((i) => i.type === "warning")
                        .map((i) => i.message)
                        .join(" | ");
                    html += `<span class="validation-icon warning" data-tooltip="${warnMsg}">âš </span>`;
                }

                html += "</div>";
                return html;
            }

            function getValidationClass(cue, index) {
                const issues = validateCue(cue, index);
                if (issues.length === 0) return "";

                const hasError = issues.some((i) => i.type === "error");
                return hasError ? "has-error" : "has-warning";
            }

            function openStatsModal() {
                // Update stats before showing
                calculateStats();
                validateAllCues();
                document.getElementById("stats-modal").classList.add("active");
            }

            function closeStatsModal() {
                document.getElementById("stats-modal").classList.remove("active");
            }

            // Initialize stats modal
            document.getElementById("stats-btn")?.addEventListener("click", openStatsModal);
            document.getElementById("close-stats-modal")?.addEventListener("click", closeStatsModal);
            document.getElementById("stats-modal")?.addEventListener("click", (e) => {
                if (e.target.id === "stats-modal") closeStatsModal();
            });

            // V3.0 - Theme System
            const THEMES = {
                dark: { icon: "ðŸŒ™", label: "Dark" },
                light: { icon: "â˜€ï¸", label: "Light" },
                blue: { icon: "ðŸ’™", label: "Blue" },
                purple: { icon: "ðŸ’œ", label: "Purple" },
                orange: { icon: "ðŸ§¡", label: "Orange" },
            };

            let currentTheme = localStorage.getItem("vtt-editor-theme") || "dark";

            function setTheme(theme) {
                currentTheme = theme;
                document.documentElement.setAttribute("data-theme", theme === "dark" ? "" : theme);

                // Update button
                const themeIcon = document.getElementById("theme-icon");
                const themeLabel = document.getElementById("theme-label");
                if (themeIcon && themeLabel) {
                    themeIcon.textContent = THEMES[theme].icon;
                    themeLabel.textContent = THEMES[theme].label;
                }

                // Update active option
                document.querySelectorAll(".theme-option").forEach((opt) => {
                    opt.classList.toggle("active", opt.dataset.theme === theme);
                });

                // Update wavesurfer colors if exists
                if (wavesurfer) {
                    const style = getComputedStyle(document.documentElement);
                    wavesurfer.setOptions({
                        waveColor: style.getPropertyValue("--waveform-wave").trim() || "#1db954",
                        progressColor: style.getPropertyValue("--waveform-progress").trim() || "#1ed760",
                    });
                }

                // Save preference
                localStorage.setItem("vtt-editor-theme", theme);
            }

            function toggleThemeDropdown() {
                document.getElementById("theme-selector")?.classList.toggle("active");
            }

            // Initialize theme
            document.addEventListener("DOMContentLoaded", () => {
                setTheme(currentTheme);
            });

            document.getElementById("theme-btn")?.addEventListener("click", toggleThemeDropdown);

            document.querySelectorAll(".theme-option").forEach((opt) => {
                opt.addEventListener("click", () => {
                    setTheme(opt.dataset.theme);
                    toggleThemeDropdown();
                });
            });

            // Close theme dropdown on outside click
            document.addEventListener("click", (e) => {
                const selector = document.getElementById("theme-selector");
                if (selector && !selector.contains(e.target)) {
                    selector.classList.remove("active");
                }
            });

            // V3.0 - Editable Markers
            let editingMarkerId = null;
            let selectedMarkerColor = "#ff6b6b";

            function openMarkerEditModal(markerId) {
                const marker = markers.find((m) => m.id === markerId);
                if (!marker) return;

                editingMarkerId = markerId;

                // Set values
                document.getElementById("marker-label-input").value = marker.label || "";
                document.getElementById("marker-time-display").textContent = formatTimeVTT(marker.time);

                // Set color
                selectedMarkerColor = marker.color || "#ff6b6b";
                document.querySelectorAll(".marker-color-option").forEach((opt) => {
                    opt.classList.toggle("selected", opt.dataset.color === selectedMarkerColor);
                });

                document.getElementById("marker-edit-modal").classList.add("active");
            }

            function closeMarkerEditModal() {
                document.getElementById("marker-edit-modal").classList.remove("active");
                editingMarkerId = null;
            }

            function saveMarker() {
                if (!editingMarkerId) return;

                const marker = markers.find((m) => m.id === editingMarkerId);
                if (!marker) return;

                marker.label = document.getElementById("marker-label-input").value.trim();
                marker.color = selectedMarkerColor;

                // Update visual marker
                renderMarkers();
                updateMinimap();
                closeMarkerEditModal();
                showToast("Marker updated", "success");
            }

            function deleteEditingMarker() {
                if (!editingMarkerId) return;

                markers = markers.filter((m) => m.id !== editingMarkerId);
                renderMarkers();
                updateMinimap();
                closeMarkerEditModal();
                showToast("Marker deleted", "info");
            }

            // Color picker for markers
            document.querySelectorAll(".marker-color-option").forEach((opt) => {
                opt.addEventListener("click", () => {
                    selectedMarkerColor = opt.dataset.color;
                    document.querySelectorAll(".marker-color-option").forEach((o) => o.classList.remove("selected"));
                    opt.classList.add("selected");
                });
            });

            document.getElementById("close-marker-modal")?.addEventListener("click", closeMarkerEditModal);
            document.getElementById("save-marker-btn")?.addEventListener("click", saveMarker);
            document.getElementById("delete-marker-btn")?.addEventListener("click", deleteEditingMarker);
            document.getElementById("marker-edit-modal")?.addEventListener("click", (e) => {
                if (e.target.id === "marker-edit-modal") closeMarkerEditModal();
            });

            // V3.0 - Minimap
            let minimapVisible = true;

            function updateMinimap() {
                if (!wavesurfer || !minimapVisible) return;

                const minimap = document.getElementById("minimap");
                const playhead = document.getElementById("minimap-playhead");
                const viewport = document.getElementById("minimap-viewport");
                if (!minimap) return;

                const duration = wavesurfer.getDuration();
                if (!duration) return;

                const minimapWidth = minimap.offsetWidth;

                // Clear existing regions and markers in minimap
                minimap.querySelectorAll(".minimap-region, .minimap-marker").forEach((el) => el.remove());

                // Add regions
                cues.forEach((cue) => {
                    const left = (cue.start / duration) * 100;
                    const width = ((cue.end - cue.start) / duration) * 100;

                    const regionEl = document.createElement("div");
                    regionEl.className = "minimap-region";
                    regionEl.style.left = left + "%";
                    regionEl.style.width = width + "%";
                    regionEl.style.background = cue.color || "var(--accent)";
                    minimap.appendChild(regionEl);
                });

                // Add markers
                markers.forEach((marker) => {
                    const left = (marker.time / duration) * 100;

                    const markerEl = document.createElement("div");
                    markerEl.className = "minimap-marker";
                    markerEl.style.left = left + "%";
                    markerEl.style.background = marker.color || "#ff6b6b";
                    markerEl.title = marker.label || "Marker";
                    minimap.appendChild(markerEl);
                });

                // Update playhead position
                const currentTime = wavesurfer.getCurrentTime();
                const playheadPos = (currentTime / duration) * 100;
                playhead.style.left = playheadPos + "%";

                // Update viewport (visible area indicator)
                // This would need scroll info from wavesurfer which is complex
                // For now, just show a simple viewport based on zoom
            }

            function toggleMinimap() {
                minimapVisible = !minimapVisible;
                const container = document.getElementById("minimap-container");
                const toggle = document.getElementById("minimap-toggle");
                const content = document.querySelector("#minimap-container .minimap");

                if (content) {
                    content.style.display = minimapVisible ? "block" : "none";
                }
                if (toggle) {
                    toggle.textContent = minimapVisible ? "Hide" : "Show";
                }
            }

            // Minimap click to seek
            document.getElementById("minimap")?.addEventListener("click", (e) => {
                if (!wavesurfer) return;

                const minimap = e.currentTarget;
                const rect = minimap.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;

                wavesurfer.seekTo(percentage);
            });

            document.getElementById("minimap-toggle")?.addEventListener("click", toggleMinimap);

            // V3.0 - Custom Dropdown System
            function initCustomDropdowns() {
                // Snap dropdown
                const snapDropdown = document.getElementById("snap-dropdown");
                const snapBtn = document.getElementById("snap-dropdown-btn");
                const snapMenu = document.getElementById("snap-dropdown-menu");
                const snapLabel = document.getElementById("snap-label");

                if (snapBtn) {
                    snapBtn.addEventListener("click", (e) => {
                        e.stopPropagation();
                        closeAllDropdowns();
                        snapDropdown.classList.toggle("active");
                    });
                }

                if (snapMenu) {
                    snapMenu.querySelectorAll(".dropdown-option").forEach((option) => {
                        option.addEventListener("click", () => {
                            const value = parseFloat(option.dataset.value);
                            snapInterval = value; // V3.0 - Update the global snapInterval variable

                            // Update label
                            snapLabel.textContent = option.querySelector(".option-name").textContent;

                            // Update active state
                            snapMenu.querySelectorAll(".dropdown-option").forEach((o) => o.classList.remove("active"));
                            option.classList.add("active");

                            // Close dropdown
                            snapDropdown.classList.remove("active");
                        });
                    });
                }

                // Track dropdown
                const trackDropdown = document.getElementById("track-dropdown");
                const trackBtn = document.getElementById("track-dropdown-btn");

                if (trackBtn) {
                    trackBtn.addEventListener("click", (e) => {
                        e.stopPropagation();
                        closeAllDropdowns();
                        trackDropdown.classList.toggle("active");
                    });
                }

                // Close dropdowns on outside click
                document.addEventListener("click", (e) => {
                    if (!e.target.closest(".custom-dropdown")) {
                        closeAllDropdowns();
                    }
                });
            }

            function closeAllDropdowns() {
                document.querySelectorAll(".custom-dropdown").forEach((d) => d.classList.remove("active"));
            }

            function updateSnapDropdownLabel(value) {
                const snapLabel = document.getElementById("snap-label");
                const snapMenu = document.getElementById("snap-dropdown-menu");
                if (!snapLabel || !snapMenu) return;

                // Find matching option and update label
                const options = snapMenu.querySelectorAll(".dropdown-option");
                options.forEach((option) => {
                    const optValue = parseFloat(option.dataset.value);
                    option.classList.remove("active");
                    if (optValue === value) {
                        option.classList.add("active");
                        snapLabel.textContent = option.querySelector(".option-name").textContent;
                    }
                });
            }

            function updateTrackDropdown() {
                const trackMenu = document.getElementById("track-dropdown-menu");
                const trackLabel = document.getElementById("track-label");
                if (!trackMenu) return;

                trackMenu.innerHTML = "";

                tracks.forEach((track) => {
                    const option = document.createElement("div");
                    option.className = "dropdown-option" + (track.id === currentTrackId ? " active" : "");
                    option.dataset.value = track.id;
                    option.innerHTML = `
                        <span class="option-name">${track.name}</span>
                        <span class="option-desc">${track.cues ? track.cues.length : 0} cues</span>
                    `;

                    option.addEventListener("click", () => {
                        switchTrack(track.id);
                        trackLabel.textContent = track.name;
                        trackMenu.querySelectorAll(".dropdown-option").forEach((o) => o.classList.remove("active"));
                        option.classList.add("active");
                        document.getElementById("track-dropdown").classList.remove("active");
                    });

                    trackMenu.appendChild(option);
                });

                // Update label to current track
                const currentTrack = getCurrentTrack();
                if (currentTrack && trackLabel) {
                    trackLabel.textContent = currentTrack.name;
                }
            }

            // Initialize custom dropdowns on load
            initCustomDropdowns();

            // Efficient playhead-only update for minimap
            function updateMinimapPlayhead() {
                if (!wavesurfer || !minimapVisible) return;

                const playhead = document.getElementById("minimap-playhead");
                if (!playhead) return;

                const duration = wavesurfer.getDuration();
                if (!duration) return;

                const currentTime = wavesurfer.getCurrentTime();
                const playheadPos = (currentTime / duration) * 100;
                playhead.style.left = playheadPos + "%";
            }

            // ===== END V3.0 FEATURES =====

            elements.audioUpload.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                audioFile = file;

                if (!wavesurfer) {
                    initWaveSurfer();
                }

                const url = URL.createObjectURL(file);
                wavesurfer.load(url);

                cues = [];
                clearAllRegions();
                renderCues();
                renderLyrics();
                clearForm();
                history = [];
                historyIndex = -1;
                saveToHistory();
                showToast(`MP3 loaded: ${file.name}`, "success");
            });

            elements.vttUpload.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // V2.2 - Check if audio is loaded first
                if (!wavesurfer || !regionsPlugin) {
                    showToast("âš ï¸ Import an audio file (MP3) before the VTT!", "error");
                    e.target.value = "";
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const content = event.target.result;
                        const parsedCues = parseVTT(content);

                        if (parsedCues.length === 0) {
                            showToast("No cue found in the VTT", "error");
                            return;
                        }

                        cues = parsedCues;
                        rebuildRegions();
                        sortCues();
                        renderCues();
                        renderLyrics();
                        saveToHistory();
                        showToast(`${parsedCues.length} cues imported from VTT`, "success");
                    } catch (err) {
                        showToast("Error during VTT import", "error");
                        console.error(err);
                    }
                };
                reader.readAsText(file);

                e.target.value = "";
                closeImportDropdown();
            });

            // V2.2 - Import SRT
            elements.srtUpload.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Check if audio is loaded first
                if (!wavesurfer || !regionsPlugin) {
                    showToast("âš ï¸ Import an audio file (MP3) before the SRT!", "error");
                    e.target.value = "";
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const content = event.target.result;
                        const parsedCues = parseSRT(content);

                        if (parsedCues.length === 0) {
                            showToast("No cue found in the SRT", "error");
                            return;
                        }

                        cues = parsedCues;
                        rebuildRegions();
                        sortCues();
                        renderCues();
                        renderLyrics();
                        saveToHistory();
                        showToast(`${parsedCues.length} cues imported from SRT`, "success");
                    } catch (err) {
                        showToast("Error during SRT import", "error");
                        console.error(err);
                    }
                };
                reader.readAsText(file);

                e.target.value = "";
                closeImportDropdown();
            });

            // V3.0 - Import ASS
            elements.assUpload.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (!wavesurfer || !regionsPlugin) {
                    showToast("âš ï¸ Import an audio file (MP3) before the ASS!", "error");
                    e.target.value = "";
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const content = event.target.result;
                        const parsedCues = parseASS(content);

                        if (parsedCues.length === 0) {
                            showToast("No cue found in the ASS", "error");
                            return;
                        }

                        cues = parsedCues;
                        rebuildRegions();
                        sortCues();
                        renderCues();
                        renderLyrics();
                        saveToHistory();
                        showToast(`${parsedCues.length} cues imported from ASS`, "success");
                    } catch (err) {
                        showToast("Error during ASS import", "error");
                        console.error(err);
                    }
                };
                reader.readAsText(file);

                e.target.value = "";
                closeImportDropdown();
            });

            // V3.0 - Import SBV
            elements.sbvUpload.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (!wavesurfer || !regionsPlugin) {
                    showToast("âš ï¸ Import an audio file (MP3) before the SBV!", "error");
                    e.target.value = "";
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const content = event.target.result;
                        const parsedCues = parseSBV(content);

                        if (parsedCues.length === 0) {
                            showToast("No cue found in the SBV", "error");
                            return;
                        }

                        cues = parsedCues;
                        rebuildRegions();
                        sortCues();
                        renderCues();
                        renderLyrics();
                        saveToHistory();
                        showToast(`${parsedCues.length} cues imported from SBV`, "success");
                    } catch (err) {
                        showToast("Error during SBV import", "error");
                        console.error(err);
                    }
                };
                reader.readAsText(file);

                e.target.value = "";
                closeImportDropdown();
            });

            // V3.0 - Import DFXP/TTML
            elements.dfxpUpload.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (!wavesurfer || !regionsPlugin) {
                    showToast("âš ï¸ Import an audio file (MP3) before the DFXP!", "error");
                    e.target.value = "";
                    return;
                }

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const content = event.target.result;
                        const parsedCues = parseDFXP(content);

                        if (parsedCues.length === 0) {
                            showToast("No cue found in the DFXP", "error");
                            return;
                        }

                        cues = parsedCues;
                        rebuildRegions();
                        sortCues();
                        renderCues();
                        renderLyrics();
                        saveToHistory();
                        showToast(`${parsedCues.length} cues imported from DFXP`, "success");
                    } catch (err) {
                        showToast("Error during DFXP import", "error");
                        console.error(err);
                    }
                };
                reader.readAsText(file);

                e.target.value = "";
                closeImportDropdown();
            });

            // V3.0 - Import JSON
            elements.jsonUpload.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const content = event.target.result;
                    if (importJSON(content)) {
                        showToast("JSON backup imported successfully!", "success");
                    }
                };
                reader.readAsText(file);

                e.target.value = "";
                closeImportDropdown();
            });

            // V3.0 - Import dropdown toggle
            elements.importDropdownBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                toggleImportDropdown();
            });

            // V3.0 - Advanced editing tools
            elements.splitCueBtn.addEventListener("click", splitCue);
            elements.mergeCuesBtn.addEventListener("click", mergeCues);
            elements.shiftTimingsBtn.addEventListener("click", openShiftModal);

            // V3.0 - Shift modal controls
            elements.closeShiftModal.addEventListener("click", closeShiftModal);
            elements.cancelShiftBtn.addEventListener("click", closeShiftModal);
            elements.applyShiftBtn.addEventListener("click", applyShift);

            elements.shiftValue.addEventListener("input", updateShiftPreview);
            elements.shiftMinus1.addEventListener("click", () => adjustShift(-1));
            elements.shiftMinus01.addEventListener("click", () => adjustShift(-0.1));
            elements.shiftPlus01.addEventListener("click", () => adjustShift(0.1));
            elements.shiftPlus1.addEventListener("click", () => adjustShift(1));

            // Quick shift buttons
            document.querySelectorAll(".shift-quick-btn").forEach((btn) => {
                btn.addEventListener("click", () => {
                    setShiftValue(parseFloat(btn.dataset.value));
                });
            });

            // Close shift modal on overlay click
            elements.shiftModal.addEventListener("click", (e) => {
                if (e.target === elements.shiftModal) {
                    closeShiftModal();
                }
            });

            // V3.0 - Search in cues
            elements.cueSearch.addEventListener("input", (e) => {
                searchCues(e.target.value);
            });

            elements.searchClear.addEventListener("click", clearSearch);

            // Keyboard shortcut: Escape to clear search
            elements.cueSearch.addEventListener("keydown", (e) => {
                if (e.key === "Escape") {
                    clearSearch();
                }
            });

            // V3.0 - Go to time
            elements.gotoTimeBtn.addEventListener("click", goToTime);

            elements.gotoTimeInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    goToTime();
                }
            });

            // Keyboard shortcut: G to focus go to time (when not in input)
            document.addEventListener("keydown", (e) => {
                if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
                    return;
                }
                if (e.key === "g" || e.key === "G") {
                    e.preventDefault();
                    elements.gotoTimeInput.focus();
                }
                // Ctrl+F to focus search
                if ((e.ctrlKey || e.metaKey) && e.key === "f") {
                    e.preventDefault();
                    elements.cueSearch.focus();
                }
            });

            elements.playBtn.addEventListener("click", () => {
                if (!wavesurfer) return;

                if (isPlaying) {
                    wavesurfer.pause();
                    isPlaying = false;
                    elements.playBtn.textContent = "â–¶ï¸ Play";
                } else {
                    wavesurfer.play();
                    isPlaying = true;
                    elements.playBtn.textContent = "â¸ï¸ Pause";
                }
            });

            elements.addRegionBtn.addEventListener("click", addQuickRegion);

            elements.zoomIn.addEventListener("click", () => {
                if (!wavesurfer) return;
                currentZoom += 20;
                wavesurfer.zoom(currentZoom);
            });

            elements.zoomOut.addEventListener("click", () => {
                if (!wavesurfer) return;
                currentZoom = Math.max(currentZoom - 20, 10);
                wavesurfer.zoom(currentZoom);
            });

            elements.undoBtn.addEventListener("click", undo);
            elements.redoBtn.addEventListener("click", redo);

            elements.markStart.addEventListener("click", markStart);
            elements.markEnd.addEventListener("click", markEnd);
            elements.addCue.addEventListener("click", addCue);
            elements.updateCue.addEventListener("click", updateCue);
            elements.deleteCurrent.addEventListener("click", deleteCurrentCue);
            elements.cancelEdit.addEventListener("click", clearForm);
            // V3.0 - Export dropdown and buttons
            elements.exportDropdownBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                toggleExportDropdown();
            });
            elements.exportVttBtn.addEventListener("click", () => {
                exportVTT();
                closeExportDropdown();
            });
            elements.exportSrtBtn.addEventListener("click", () => {
                exportSRT();
                closeExportDropdown();
            });
            elements.exportAssBtn.addEventListener("click", exportASS);
            elements.exportSbvBtn.addEventListener("click", exportSBV);
            elements.exportDfxpBtn.addEventListener("click", exportDFXP);
            elements.exportJsonBtn.addEventListener("click", exportJSON);

            elements.clearAll.addEventListener("click", clearAllCues);

            elements.randomColor.addEventListener("click", () => {
                elements.regionColor.value = generateRandomColor();
            });

            elements.allowOverlap.addEventListener("change", (e) => {
                allowOverlap = e.target.checked;
                renderCues();
                if (allowOverlap) {
                    showToast("Overlaps allowed âš ï¸", "warning");
                } else {
                    showToast("Overlaps blocked âœ…", "success");
                }
            });

            elements.cueStart.addEventListener("input", () => {
                if (currentCueId) {
                    const start = parseFloat(elements.cueStart.value);
                    const end = parseFloat(elements.cueEnd.value);
                    const cue = cues.find((c) => c.id === currentCueId);
                    if (!isNaN(start) && !isNaN(end) && start < end && cue) {
                        updateRegion(currentCueId, start, end, cue.color);
                    }
                }
            });

            elements.cueEnd.addEventListener("input", () => {
                if (currentCueId) {
                    const start = parseFloat(elements.cueStart.value);
                    const end = parseFloat(elements.cueEnd.value);
                    const cue = cues.find((c) => c.id === currentCueId);
                    if (!isNaN(start) && !isNaN(end) && start < end && cue) {
                        updateRegion(currentCueId, start, end, cue.color);
                    }
                }
            });

            elements.regionColor.addEventListener("input", () => {
                if (currentCueId) {
                    const start = parseFloat(elements.cueStart.value);
                    const end = parseFloat(elements.cueEnd.value);
                    const color = elements.regionColor.value;
                    const cue = cues.find((c) => c.id === currentCueId);
                    if (!isNaN(start) && !isNaN(end) && start < end && cue) {
                        cue.color = color;
                        updateRegion(currentCueId, start, end, color);
                        renderCues();
                    }
                }
            });

            // V2.2 - Track mouse position for tooltip
            document.addEventListener("mousemove", (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            document.addEventListener("keydown", (e) => {
                if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
                    if (e.ctrlKey && e.key === "Enter") {
                        e.preventDefault();
                        if (currentCueId) {
                            updateCue();
                        } else {
                            addCue();
                        }
                    }
                    return;
                }

                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case "z":
                            e.preventDefault();
                            undo();
                            break;
                        case "y":
                            e.preventDefault();
                            redo();
                            break;
                        case "s":
                            e.preventDefault();
                            markStart();
                            break;
                        case "b":
                            e.preventDefault();
                            markEnd();
                            break;
                    }
                    return;
                }

                switch (e.code) {
                    case "Space":
                        e.preventDefault();
                        elements.playBtn.click();
                        break;
                    case "ArrowLeft":
                        e.preventDefault();
                        if (wavesurfer) {
                            const time = Math.max(wavesurfer.getCurrentTime() - 1, 0);
                            wavesurfer.seekTo(time / wavesurfer.getDuration());
                        }
                        break;
                    case "ArrowRight":
                        e.preventDefault();
                        if (wavesurfer) {
                            const time = Math.min(wavesurfer.getCurrentTime() + 1, wavesurfer.getDuration());
                            wavesurfer.seekTo(time / wavesurfer.getDuration());
                        }
                        break;
                    case "Delete":
                        e.preventDefault();
                        if (activeRegion) {
                            const cue = cues.find((c) => c.id === activeRegion.id);
                            if (cue) {
                                deleteCue(cue.id);
                            }
                        }
                        break;
                }
            });

            // ===== V2.1 EVENT LISTENERS =====

            // Snap-to-Grid controls
            elements.snapEnabled.addEventListener("change", enableSnapToGrid);
            // V3.0 - snapInterval is now handled by custom dropdown in initCustomDropdowns()

            // Batch Edit Modal
            elements.batchEditBtn.addEventListener("click", openBatchModal);
            elements.closeBatchModal.addEventListener("click", closeBatchModal);

            // Close modal on overlay click
            elements.batchModal.addEventListener("click", (e) => {
                if (e.target === elements.batchModal) {
                    closeBatchModal();
                }
            });

            // Batch tabs switching
            document.querySelectorAll(".batch-tab").forEach((tab) => {
                tab.addEventListener("click", () => {
                    // Remove active from all tabs and panels
                    document.querySelectorAll(".batch-tab").forEach((t) => t.classList.remove("active"));
                    document.querySelectorAll(".batch-panel").forEach((p) => p.classList.remove("active"));

                    // Add active to clicked tab and corresponding panel
                    tab.classList.add("active");
                    const tabName = tab.dataset.tab;
                    document.getElementById(`${tabName}-panel`).classList.add("active");
                });
            });

            // Batch operations
            elements.applyReplace.addEventListener("click", batchFindReplace);

            elements.transformUppercase.addEventListener("click", () => batchTransform("uppercase"));
            elements.transformLowercase.addEventListener("click", () => batchTransform("lowercase"));
            elements.transformCapitalize.addEventListener("click", () => batchTransform("capitalize"));
            elements.transformSentence.addEventListener("click", () => batchTransform("sentence"));

            elements.applyPrefix.addEventListener("click", () => batchModify("prefix"));
            elements.applySuffix.addEventListener("click", () => batchModify("suffix"));
            elements.applyBoth.addEventListener("click", () => batchModify("both"));

            // Enable batch edit button when cues exist
            function updateBatchEditBtn() {
                elements.batchEditBtn.disabled = cues.length === 0;
            }

            // Update batch button state when cues change
            const originalRenderCues = renderCues;
            renderCues = function () {
                originalRenderCues.call(this);
                updateBatchEditBtn();
                updateAdvancedEditButtons(); // V3.0
                // V3.0 - Reapply search filter after render
                if (currentSearchQuery) {
                    searchCues(currentSearchQuery);
                }
            };

            // ===== END V2.1 EVENT LISTENERS =====

            // ===== V2.2 EVENT LISTENERS =====

            // Markers
            elements.addMarkerBtn.addEventListener("click", addMarker);
            elements.clearMarkersBtn.addEventListener("click", clearAllMarkers);

            // Tracks
            elements.manageTracksBtn.addEventListener("click", openTrackModal);
            elements.closeTrackModal.addEventListener("click", closeTrackModal);

            elements.trackModal.addEventListener("click", (e) => {
                if (e.target === elements.trackModal) {
                    closeTrackModal();
                }
            });

            // V3.0 - Track select is now handled by custom dropdown in initCustomDropdowns()

            elements.createTrackBtn.addEventListener("click", () => {
                const name = elements.newTrackName.value;
                createTrack(name);
                elements.newTrackName.value = "";
            });

            elements.newTrackName.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    const name = elements.newTrackName.value;
                    createTrack(name);
                    elements.newTrackName.value = "";
                }
            });

            // V3.0 - Buttons now enabled directly in initWaveSurfer 'ready' handler

            // Add keyboard shortcut for marker (M key)
            const originalKeydown = document.addEventListener;
            document.addEventListener("keydown", (e) => {
                if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
                    return;
                }

                if (e.key === "m" || e.key === "M") {
                    e.preventDefault();
                    addMarker();
                }
            });

            // ===== END V2.2 EVENT LISTENERS =====

            renderCues();
            renderLyrics();
        </script>
    </body>
</html>